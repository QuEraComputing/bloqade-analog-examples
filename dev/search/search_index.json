{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tutorials","text":"<p>Below you will find many tutorials on how to use Bloqade. We begin with single qubit examples and work our way up to complex dynamics of any qubits. We also show how to use Bloqade to solve the Maximal Independent Set problem on a defective King Graph.</p> <p>Single Qubit Rabi Oscillation</p> <p>Single Qubit Ramsey Protocol</p> <p>Single Qubit Floquet Dynamics</p> <p>Two Qubit Adiabatic Sweep</p> <p>Multi-qubit Blockaded Rabi Oscillations</p> <p>Nonequilibrium Dynamics of nearly Blockaded Rydberg Atoms</p> <p>1D Z2 State Preparation</p> <p>2D State Preparation</p> <p>Quantum Scar Dynamics</p> <p>Solving the Maximal Independent Set Problem on defective King Graph</p> <p>Lattice Gauge Theory Simulation</p>"},{"location":"examples/example-1-floquet/","title":"Single Qubit Floquet Dynamics","text":"<p> Download Script   Download Job </p> <p>Job Files for Complete Examples</p> <p> To be able to run the complete examples without having to submit your program to hardware and wait, you'll need to download the associated job files. These files contain the results of running the program on the quantum hardware.  <p>You can download the job files by clicking the \"Download _ Job\" button above. You'll then need to place the job file in the <code>data</code> directory that was created for you when you ran the <code>import</code> part of the script (alternatively you can make the directory yourself, it should live at the same level as wherever you put this script).</p> </p> In\u00a0[1]: Copied! <pre>import os\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom bloqade.analog import cast, load, save, start\n\nif not os.path.isdir(\"data\"):\n    os.mkdir(\"data\")\n</pre> import os  import numpy as np import matplotlib.pyplot as plt from bloqade.analog import cast, load, save, start  if not os.path.isdir(\"data\"):     os.mkdir(\"data\") In\u00a0[2]: Copied! <pre>min_time_step = 0.05\n\ndurations = cast([\"ramp_time\", \"run_time\", \"ramp_time\"])\n\n\ndef detuning_wf(t, drive_amplitude, drive_frequency):\n    return drive_amplitude * np.sin(drive_frequency * t)\n\n\nfloquet_program = (\n    start.add_position((0, 0))\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(\n        durations, [0, \"rabi_max\", \"rabi_max\", 0]\n    )\n    .detuning.uniform.fn(detuning_wf, sum(durations))\n    .sample(\"min_time_step\", \"linear\")\n)\n</pre>  min_time_step = 0.05  durations = cast([\"ramp_time\", \"run_time\", \"ramp_time\"])   def detuning_wf(t, drive_amplitude, drive_frequency):     return drive_amplitude * np.sin(drive_frequency * t)   floquet_program = (     start.add_position((0, 0))     .rydberg.rabi.amplitude.uniform.piecewise_linear(         durations, [0, \"rabi_max\", \"rabi_max\", 0]     )     .detuning.uniform.fn(detuning_wf, sum(durations))     .sample(\"min_time_step\", \"linear\") ) <p>We assign values to the necessary variables and then run_async the program to both the emulator and actual hardware.</p> In\u00a0[3]: Copied! <pre>run_times = np.linspace(0.05, 3.0, 101)\n\nfloquet_job = floquet_program.assign(\n    ramp_time=0.06,\n    min_time_step=0.05,\n    rabi_max=15,\n    drive_amplitude=15,\n    drive_frequency=15,\n).batch_assign(run_time=run_times)\n</pre> run_times = np.linspace(0.05, 3.0, 101)  floquet_job = floquet_program.assign(     ramp_time=0.06,     min_time_step=0.05,     rabi_max=15,     drive_amplitude=15,     drive_frequency=15, ).batch_assign(run_time=run_times) <p>have to start the time at 0.05 because the hardware does not support anything less than that time step. We can now run_async the job to the emulator and hardware.</p> In\u00a0[4]: Copied! <pre>emu_filename = os.path.join(os.path.abspath(\"\"), \"data\", \"floquet-emulation.json\")\nprint(emu_filename)\n\nif not os.path.isfile(emu_filename):\n    emu_batch = floquet_job.bloqade.python().run(10000)\n    save(emu_batch, emu_filename)\n\nhardware_filename = os.path.join(os.path.abspath(\"\"), \"data\", \"floquet-job.json\")\n\nif not os.path.isfile(hardware_filename):\n    batch = floquet_job.parallelize(24).braket.aquila().run_async(shots=50)\n    save(batch, hardware_filename)\n</pre> emu_filename = os.path.join(os.path.abspath(\"\"), \"data\", \"floquet-emulation.json\") print(emu_filename)  if not os.path.isfile(emu_filename):     emu_batch = floquet_job.bloqade.python().run(10000)     save(emu_batch, emu_filename)  hardware_filename = os.path.join(os.path.abspath(\"\"), \"data\", \"floquet-job.json\")  if not os.path.isfile(hardware_filename):     batch = floquet_job.parallelize(24).braket.aquila().run_async(shots=50)     save(batch, hardware_filename) <pre>/home/runner/work/bloqade-analog-examples/bloqade-analog-examples/data/floquet-emulation.json\n</pre> In\u00a0[5]: Copied! <pre>emu_batch = load(emu_filename)\nassert not isinstance(emu_batch, dict)\nhardware_batch = load(hardware_filename)\nassert not isinstance(hardware_batch, dict)\n# hardware_batch.fetch()\n# save(filename, hardware_batch)\n</pre> emu_batch = load(emu_filename) assert not isinstance(emu_batch, dict) hardware_batch = load(hardware_filename) assert not isinstance(hardware_batch, dict) # hardware_batch.fetch() # save(filename, hardware_batch) <pre>/home/runner/work/bloqade-analog-examples/bloqade-analog-examples/.venv/lib/python3.12/site-packages/bloqade/analog/ir/control/waveform.py:903: UserWarning: Python function detuning_wf in the program cannot be serialized. The rest of the program can be deserialized but you cannot rerun this task.\n  warnings.warn(self.error_message)\n</pre> <p>Next we extract the run times and the Rydberg population from the report. We can then plot the results.</p> In\u00a0[6]: Copied! <pre>hardware_report = hardware_batch.report()\nemulator_report = emu_batch.report()\n\ntimes = emulator_report.list_param(\"run_time\")\ndensity = [1 - ele.mean() for ele in emulator_report.bitstrings()]\nplt.plot(times, density, color=\"#878787\", marker=\".\", label=\"Emulator\")\n\ntimes = hardware_report.list_param(\"run_time\")\ndensity = [1 - ele.mean() for ele in hardware_report.bitstrings()]\n\nplt.plot(times, density, color=\"#6437FF\", linewidth=4, label=\"QPU\")\nplt.xlabel(\"Time ($\\mu s$)\")\nplt.ylabel(\"Rydberg population\")\nplt.legend()\nplt.show()\n</pre>  hardware_report = hardware_batch.report() emulator_report = emu_batch.report()  times = emulator_report.list_param(\"run_time\") density = [1 - ele.mean() for ele in emulator_report.bitstrings()] plt.plot(times, density, color=\"#878787\", marker=\".\", label=\"Emulator\")  times = hardware_report.list_param(\"run_time\") density = [1 - ele.mean() for ele in hardware_report.bitstrings()]  plt.plot(times, density, color=\"#6437FF\", linewidth=4, label=\"QPU\") plt.xlabel(\"Time ($\\mu s$)\") plt.ylabel(\"Rydberg population\") plt.legend() plt.show() <pre>&lt;&gt;:12: SyntaxWarning: invalid escape sequence '\\m'\n&lt;&gt;:12: SyntaxWarning: invalid escape sequence '\\m'\n/tmp/ipykernel_2024/2886382284.py:12: SyntaxWarning: invalid escape sequence '\\m'\n  plt.xlabel(\"Time ($\\mu s$)\")\n</pre>"},{"location":"examples/example-1-floquet/#single-qubit-floquet-dynamics","title":"Single Qubit Floquet Dynamics\u00b6","text":""},{"location":"examples/example-1-floquet/#introduction","title":"Introduction\u00b6","text":"<p>Rounding out the single qubit examples we will show how to generate a Floquet protocol. We will define the protocol using a python function and then use the Bloqade API to sample the function at certain intervals to make it compatible with the hardware, which only supports piecewise linear/constant functions. First let us start with the imports.</p>"},{"location":"examples/example-1-floquet/#define-the-program","title":"Define the program.\u00b6","text":"<p>For the Floquet protocol we keep We do the same Rabi drive but allow the detuning to vary sinusoidally. We do this by defining a smooth function for the detuning and then sampling it at certain intervals (in this case, the minimum hardware-supported time step). Note that the <code>sample</code> method will always sample at equal to or greater than the specified time step. If the total time interval is not divisible by the time step, the last time step will be larger than the specified time step. Also note that the arguments of your function must be named arguments, e.g. no <code>*args</code> or <code>**kwargs</code>, because Bloqade will analyze the function signature to and generate variables for each argument.</p>"},{"location":"examples/example-1-floquet/#run-emulator-and-hardware","title":"Run Emulator and Hardware\u00b6","text":"<p>Like in the first tutorial, we will run the program on the emulator and hardware. Note that for the hardware we will use the <code>parallelize</code> method to run multiple copies of the program in parallel. For more information about this process, see the first tutorial.</p> <p>Hardware Execution Cost</p> <p> <p>For this particular program, 101 tasks are generated with each task having 50 shots, amounting to USD \\$80.80 on AWS Braket.</p> </p>"},{"location":"examples/example-1-floquet/#plotting-the-results","title":"Plotting the Results\u00b6","text":"<p>Exactly like in the Rabi Oscillation example, we can now plot the results from the hardware and emulation together. Again we will use the <code>report</code> to calculate the mean Rydberg population for each run, and then plot the results.</p> <p>first we load the results from the emulation and hardware.</p>"},{"location":"examples/example-1-rabi/","title":"Single Qubit Rabi Oscillations","text":"<p> Download Script   Download Job </p> <p>Job Files for Complete Examples</p> <p> To be able to run the complete examples without having to submit your program to hardware and wait, you'll need to download the associated job files. These files contain the results of running the program on the quantum hardware.  <p>You can download the job files by clicking the \"Download Job\" button above. You'll then need to place the job file in the <code>data</code> directory that was created for you when you ran the <code>import</code> part of the script (alternatively you can make the directory yourself, it should live at the same level as wherever you put this script).</p> </p> In\u00a0[1]: Copied! <pre>import os\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom bloqade.analog import cast, load, save, start\n\nif not os.path.isdir(\"data\"):\n    os.mkdir(\"data\")\n</pre> import os  import numpy as np import matplotlib.pyplot as plt from bloqade.analog import cast, load, save, start  if not os.path.isdir(\"data\"):     os.mkdir(\"data\") In\u00a0[2]: Copied! <pre>durations = cast([\"ramp_time\", \"run_time\", \"ramp_time\"])\n\nrabi_oscillations_program = (\n    start.add_position((0, 0))\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(\n        durations=durations, values=[0, \"rabi_ampl\", \"rabi_ampl\", 0]\n    )\n    .detuning.uniform.constant(duration=sum(durations), value=\"detuning_value\")\n)\n</pre> durations = cast([\"ramp_time\", \"run_time\", \"ramp_time\"])  rabi_oscillations_program = (     start.add_position((0, 0))     .rydberg.rabi.amplitude.uniform.piecewise_linear(         durations=durations, values=[0, \"rabi_ampl\", \"rabi_ampl\", 0]     )     .detuning.uniform.constant(duration=sum(durations), value=\"detuning_value\") ) In\u00a0[3]: Copied! <pre>run_times = np.linspace(0, 3, 101)\n\nrabi_oscillation_job = rabi_oscillations_program.assign(\n    ramp_time=0.06, rabi_ampl=15, detuning_value=0.0\n).batch_assign(run_time=run_times)\n</pre> run_times = np.linspace(0, 3, 101)  rabi_oscillation_job = rabi_oscillations_program.assign(     ramp_time=0.06, rabi_ampl=15, detuning_value=0.0 ).batch_assign(run_time=run_times) In\u00a0[4]: Copied! <pre>emu_filename = os.path.join(os.path.abspath(\"\"), \"data\", \"rabi-emulation.json\")\n\nif not os.path.isfile(emu_filename):\n    emu_batch = rabi_oscillation_job.bloqade.python().run(10000)\n    save(emu_batch, emu_filename)\n</pre>  emu_filename = os.path.join(os.path.abspath(\"\"), \"data\", \"rabi-emulation.json\")  if not os.path.isfile(emu_filename):     emu_batch = rabi_oscillation_job.bloqade.python().run(10000)     save(emu_batch, emu_filename) <p>When running on the hardware we can use the <code>braket</code> provider. However, we will need to specify the device to run on. In this case we will use Aquila via the <code>aquila</code> method. Before that we must note that because Aquila can support up to 256 atoms in an area that is $75 \\times 76 \\mu m^2$. We need to make full use of the capabilities of the device. Bloqade automatically takes care of this with the <code>parallelize</code> method, which will allow us to run multiple copies of the program in parallel using the full user provided area of Aquila. The <code>parallelize</code> method takes a single argument, which is the distance between each copy of the program on a grid. In this case, we want to make sure that the distance between each atom is at least 24 micrometers, so that the Rydberg interactions between atoms are negligible.</p> <p>To run the program but not wait for the results, we can use the <code>run_async</code> method, which will return a <code>Batch</code> object that can be used to fetch the results later. After running the program, we dump the results to a file so that we can use them later. Note that if you want to wait for the results in the python script just call the <code>run</code> method instead of <code>run_async</code>. This will block the script until all results in the batch are complete.</p> <p>Hardware Execution Cost</p> <p> <p>For this particular program, 101 tasks are generated with each task having 1000 shots, amounting to USD \\$1040.30 on AWS Braket.</p> </p> In\u00a0[5]: Copied! <pre>hardware_filename = os.path.join(os.path.abspath(\"\"), \"data\", \"rabi-job.json\")\n\nif not os.path.isfile(hardware_filename):\n    batch = rabi_oscillation_job.parallelize(24).braket.aquila().run_async(1000)\n    save(batch, hardware_filename)\n</pre> hardware_filename = os.path.join(os.path.abspath(\"\"), \"data\", \"rabi-job.json\")  if not os.path.isfile(hardware_filename):     batch = rabi_oscillation_job.parallelize(24).braket.aquila().run_async(1000)     save(batch, hardware_filename) In\u00a0[6]: Copied! <pre>emu_batch = load(emu_filename)\nhardware_batch = load(hardware_filename)\n# hardware_batch.fetch()\n# save(filename, hardware_batch)\n</pre> emu_batch = load(emu_filename) hardware_batch = load(hardware_filename) # hardware_batch.fetch() # save(filename, hardware_batch) In\u00a0[7]: Copied! <pre>hardware_report = hardware_batch.report()\nemulator_report = emu_batch.report()\n\ntimes = emulator_report.list_param(\"run_time\")\ndensity = [1 - ele.mean() for ele in emulator_report.bitstrings()]\nplt.plot(times, density, color=\"#878787\", marker=\".\", label=\"Emulator\")\n\ntimes = hardware_report.list_param(\"run_time\")\ndensity = [1 - ele.mean() for ele in hardware_report.bitstrings()]\nplt.plot(times, density, color=\"#6437FF\", linewidth=4, label=\"QPU\")\n\nplt.xlabel(\"Time ($\\mu s$)\")\nplt.ylabel(\"Rydberg population\")\nplt.legend()\nplt.show()\n</pre> hardware_report = hardware_batch.report() emulator_report = emu_batch.report()  times = emulator_report.list_param(\"run_time\") density = [1 - ele.mean() for ele in emulator_report.bitstrings()] plt.plot(times, density, color=\"#878787\", marker=\".\", label=\"Emulator\")  times = hardware_report.list_param(\"run_time\") density = [1 - ele.mean() for ele in hardware_report.bitstrings()] plt.plot(times, density, color=\"#6437FF\", linewidth=4, label=\"QPU\")  plt.xlabel(\"Time ($\\mu s$)\") plt.ylabel(\"Rydberg population\") plt.legend() plt.show() <pre>&lt;&gt;:12: SyntaxWarning: invalid escape sequence '\\m'\n&lt;&gt;:12: SyntaxWarning: invalid escape sequence '\\m'\n/tmp/ipykernel_2067/687603121.py:12: SyntaxWarning: invalid escape sequence '\\m'\n  plt.xlabel(\"Time ($\\mu s$)\")\n</pre>"},{"location":"examples/example-1-rabi/#single-qubit-rabi-oscillations","title":"Single Qubit Rabi Oscillations\u00b6","text":""},{"location":"examples/example-1-rabi/#introduction","title":"Introduction\u00b6","text":"<p>In this example we show how to use Bloqade to emulate Rabi oscillations of a Neutral Atom and run it on hardware. We will define a Rabi oscillation as a sequence with a constant detuning and Rabi frequency. In practice, the Rabi frequency has to start and end at 0.0, so we will use a piecewise linear function to ramp up and down the Rabi frequency.</p>"},{"location":"examples/example-1-rabi/#define-the-program","title":"Define the program.\u00b6","text":"<p>Below we define program with one atom, with constant detuning but variable Rabi frequency, ramping up to \"rabi_ampl\" and then returning to 0.0. Note that the <code>cast</code> function can be used to create a variable that can used in multiple places in the program. These variables support basic arithmetic operations, such as addition, subtraction,  multiplication, and division. They also have <code>min</code> and <code>max</code> methods that can be used in place of built-in python <code>min</code> and <code>max</code> functions, e.g. <code>cast(\"a\").min(cast(\"b\"))</code>.</p>"},{"location":"examples/example-1-rabi/#assign-values-to-the-variables-in-the-program","title":"Assign values to the variables in the program,\u00b6","text":"<p>Once your program is built, you can use the <code>assign</code> method to assign values to the variables in the program. These values must be numeric, and can be either <code>int</code>, <code>float</code>, or <code>Decimal</code> (from the <code>decimal</code> module). Note that the <code>Decimal</code> type is used to represent real numbers exactly, whereas <code>float</code> is a 64-bit floating point number that is only accurate to about 15 decimal places. The <code>Decimal</code> type is recommended for Bloqade programs, as it will ensure that your program is simulated and run with the highest possible precision. We can also do a parameter scan using the  <code>batch_assign</code> method, which will create a different program for each value provided in the list. In this case, we are sweeping the <code>run_time</code> variable, which is the time that the Rabi amplitude stays at the value of <code>rabi_ampl</code>.</p>"},{"location":"examples/example-1-rabi/#run-emulator-and-hardware","title":"Run Emulator and Hardware\u00b6","text":"<p>To run the program on the emulator we can select the <code>bloqade</code> provider as a property of the <code>batch</code> object. Bloqade has its own emulator that we can use to run the program. To do this select <code>python()</code> as the next option followed by the <code>run</code> method. Then we dump the results to a file so that we can use them later. Note that unlike the actual hardware  the shots do not correspond to multiple executions of the emulator, but rather the number of times the final wavefunction is sampled. This is because the emulator does not simulate any noise.</p>"},{"location":"examples/example-1-rabi/#plotting-the-results","title":"Plotting the Results\u00b6","text":"<p>The quantity of interest in this example is the probability of finding the atom in the Rydberg state, which is given by the <code>0</code> measurement outcome. The reason that <code>0</code> is the Rydberg state is because the in the actual device the Rydberg atoms are pushed out of the trap area and show up as a dark spot in the image. To get the probability of being in the Rydberg state, we can use the <code>bitstrings</code> method of the <code>Report</code> object, which returns a list of numpy arrays containing the measurement outcomes for each shot. We can then use the <code>mean</code> method of the numpy array to get the probability of being in the Rydberg state for each shot. We can then plot the results as a function of time. the time value can be obtained from the <code>run_time</code> parameter of the <code>Report</code> object as a list.</p> <p>before that we need to load the results from our previously saved files using the <code>load</code> function from bloqade.analog:</p>"},{"location":"examples/example-1-ramsey/","title":"Single Qubit Ramsey Protocol","text":"<p> Download Script   Download Job </p> <p>Job Files for Complete Examples</p> <p> To be able to run the complete examples without having to submit your program to hardware and wait, you'll need to download the associated job files. These files contain the results of running the program on the quantum hardware.  <p>You can download the job files by clicking the \"Download Job\" button above. You'll then need to place the job file in the <code>data</code> directory that was created for you when you ran the <code>import</code> part of the script (alternatively you can make the directory yourself, it should live at the same level as wherever you put this script).</p> </p> In\u00a0[1]: Copied! <pre>import os\nfrom decimal import Decimal\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom bloqade.analog import cast, load, save, start\n\nif not os.path.isdir(\"data\"):\n    os.mkdir(\"data\")\n</pre> import os from decimal import Decimal  import numpy as np import matplotlib.pyplot as plt from bloqade.analog import cast, load, save, start  if not os.path.isdir(\"data\"):     os.mkdir(\"data\") In\u00a0[2]: Copied! <pre>plateau_time = (np.pi / 2 - 0.625) / 12.5\nwf_durations = cast([0.05, plateau_time, 0.05, \"run_time\", 0.05, plateau_time, 0.05])\nrabi_wf_values = [0.0, 12.5, 12.5, 0.0] * 2  # repeat values twice\n\nramsey_program = (\n    start.add_position((0, 0))\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(wf_durations, rabi_wf_values)\n    .detuning.uniform.constant(10.5, sum(wf_durations))\n)\n</pre> plateau_time = (np.pi / 2 - 0.625) / 12.5 wf_durations = cast([0.05, plateau_time, 0.05, \"run_time\", 0.05, plateau_time, 0.05]) rabi_wf_values = [0.0, 12.5, 12.5, 0.0] * 2  # repeat values twice  ramsey_program = (     start.add_position((0, 0))     .rydberg.rabi.amplitude.uniform.piecewise_linear(wf_durations, rabi_wf_values)     .detuning.uniform.constant(10.5, sum(wf_durations)) ) <p>Assign values to the variables in the program, allowing <code>run_time</code> (time gap between the two pi/2 pulses) to sweep across a range of values.</p> In\u00a0[3]: Copied! <pre>n_steps = 100\nmax_time = Decimal(\"3.0\")\ndt = (max_time - Decimal(\"0.05\")) / n_steps\nrun_times = [Decimal(\"0.05\") + dt * i for i in range(101)]\n\nramsey_job = ramsey_program.batch_assign(run_time=run_times)\n</pre> n_steps = 100 max_time = Decimal(\"3.0\") dt = (max_time - Decimal(\"0.05\")) / n_steps run_times = [Decimal(\"0.05\") + dt * i for i in range(101)]  ramsey_job = ramsey_program.batch_assign(run_time=run_times) In\u00a0[4]: Copied! <pre>emu_filename = os.path.join(os.path.abspath(\"\"), \"data\", \"ramsey-emulation.json\")\n\nif not os.path.isfile(emu_filename):\n    emu_batch = ramsey_job.bloqade.python().run(10000)\n    save(emu_batch, emu_filename)\n\nhardware_filename = os.path.join(os.path.abspath(\"\"), \"data\", \"ramsey-job.json\")\nif not os.path.isfile(hardware_filename):\n    batch = ramsey_job.parallelize(24).braket.aquila().run_async(shots=100)\n    save(batch, hardware_filename)\n</pre> emu_filename = os.path.join(os.path.abspath(\"\"), \"data\", \"ramsey-emulation.json\")  if not os.path.isfile(emu_filename):     emu_batch = ramsey_job.bloqade.python().run(10000)     save(emu_batch, emu_filename)  hardware_filename = os.path.join(os.path.abspath(\"\"), \"data\", \"ramsey-job.json\") if not os.path.isfile(hardware_filename):     batch = ramsey_job.parallelize(24).braket.aquila().run_async(shots=100)     save(batch, hardware_filename) In\u00a0[5]: Copied! <pre>emu_batch = load(emu_filename)\nhardware_batch = load(hardware_filename)\n# hardware_batch.fetch()\n# save(filename, hardware_batch)\n</pre> emu_batch = load(emu_filename) hardware_batch = load(hardware_filename) # hardware_batch.fetch() # save(filename, hardware_batch) <p>Next we can calculate the Rydberg population for each run and plot the results.</p> In\u00a0[6]: Copied! <pre>hardware_report = hardware_batch.report()\nemulator_report = emu_batch.report()\n\ntimes = emulator_report.list_param(\"run_time\")\ndensity = [1 - ele.mean() for ele in emulator_report.bitstrings()]\nplt.plot(times, density, color=\"#878787\", marker=\".\", label=\"Emulator\")\n\ntimes = hardware_report.list_param(\"run_time\")\ndensity = [1 - ele.mean() for ele in hardware_report.bitstrings()]\n\nplt.plot(times, density, color=\"#6437FF\", linewidth=4, label=\"QPU\")\nplt.xlabel(\"Time ($\\mu s$)\")\nplt.ylabel(\"Rydberg population\")\nplt.legend()\nplt.show()\n</pre>  hardware_report = hardware_batch.report() emulator_report = emu_batch.report()  times = emulator_report.list_param(\"run_time\") density = [1 - ele.mean() for ele in emulator_report.bitstrings()] plt.plot(times, density, color=\"#878787\", marker=\".\", label=\"Emulator\")  times = hardware_report.list_param(\"run_time\") density = [1 - ele.mean() for ele in hardware_report.bitstrings()]  plt.plot(times, density, color=\"#6437FF\", linewidth=4, label=\"QPU\") plt.xlabel(\"Time ($\\mu s$)\") plt.ylabel(\"Rydberg population\") plt.legend() plt.show() <pre>&lt;&gt;:12: SyntaxWarning: invalid escape sequence '\\m'\n&lt;&gt;:12: SyntaxWarning: invalid escape sequence '\\m'\n/tmp/ipykernel_2132/2886382284.py:12: SyntaxWarning: invalid escape sequence '\\m'\n  plt.xlabel(\"Time ($\\mu s$)\")\n</pre>"},{"location":"examples/example-1-ramsey/#single-qubit-ramsey-protocol","title":"Single Qubit Ramsey Protocol\u00b6","text":""},{"location":"examples/example-1-ramsey/#introduction","title":"Introduction\u00b6","text":"<p>In this example we show how to use Bloqade to emulate a Ramsey protocol as well as run it on hardware. We will define a Ramsey protocol as a sequence of two $\\pi/2$ pulses separated by a variable time gap $\\tau$. These protocols are used to measure the coherence time of a qubit. In practice, the Rabi frequency has to start and end at 0.0, so we will use a piecewise linear function to ramp up and down the Rabi frequency.</p>"},{"location":"examples/example-1-ramsey/#define-the-program","title":"Define the program.\u00b6","text":"<p>define program with one atom, with constant detuning but variable Rabi frequency, where an initial pi/2 pulse is applied, followed by some time gap and a -pi/2 pulse. Note that the plateau time was chosen such that the area under the curve is pi/2 given given the constraint on how fast the Rabi frequency can change as well as the minimum allowed time step.</p>"},{"location":"examples/example-1-ramsey/#run-emulation-and-hardware","title":"Run Emulation and Hardware\u00b6","text":"<p>Like in the first tutorial, we will run the program on the emulator and hardware. Note that for the hardware we will use the <code>parallelize</code> method to run multiple copies of the program in parallel. For more information about this process, see the first tutorial.</p> <p>Hardware Execution Cost</p> <p> <p>For this particular program, 101 tasks are generated with each task having 100 shots, amounting to USD \\$131.30 on AWS Braket.</p> </p>"},{"location":"examples/example-1-ramsey/#plot-the-results","title":"Plot the results\u00b6","text":"<p>Exactly like in the Rabi Oscillation example, we can now plot the results from the hardware and emulation together. Again we will use the <code>report</code> to calculate the mean Rydberg population for each run, and then plot the results.</p> <p>first we load the results from the emulation and hardware.</p>"},{"location":"examples/example-2-multi-qubit-blockaded/","title":"Multi-qubit Blockaded Rabi Oscillations","text":"<p> Download Script   Download Job </p> <p>Job Files for Complete Examples</p> <p> To be able to run the complete examples without having to submit your program to hardware and wait, you'll need to download the associated job files. These files contain the results of running the program on the quantum hardware.  <p>You can download the job files by clicking the \"Download Job\" button above. You'll then need to place the job file in the <code>data</code> directory that was created for you when you ran the <code>import</code> part of the script (alternatively you can make the directory yourself, it should live at the same level as wherever you put this script).</p> </p> In\u00a0[1]: Copied! <pre>import os\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom bloqade.analog import load, save, start\nfrom bloqade.analog.atom_arrangement import Chain, Square\n\nif not os.path.isdir(\"data\"):\n    os.mkdir(\"data\")\n</pre> import os  import numpy as np import matplotlib.pyplot as plt from bloqade.analog import load, save, start from bloqade.analog.atom_arrangement import Chain, Square  if not os.path.isdir(\"data\"):     os.mkdir(\"data\") In\u00a0[2]: Copied! <pre>distance = 4.0\ninv_sqrt_2_rounded = 2.6\n\ngeometries = {\n    1: Chain(1),\n    2: Chain(2, lattice_spacing=distance),\n    3: start.add_position(\n        [(-inv_sqrt_2_rounded, 0.0), (inv_sqrt_2_rounded, 0.0), (0, distance)]\n    ),\n    4: Square(2, lattice_spacing=distance),\n    7: start.add_position(\n        [\n            (0, 0),\n            (distance, 0),\n            (-0.5 * distance, distance),\n            (0.5 * distance, distance),\n            (1.5 * distance, distance),\n            (0, 2 * distance),\n            (distance, 2 * distance),\n        ]\n    ),\n}\n</pre>  distance = 4.0 inv_sqrt_2_rounded = 2.6  geometries = {     1: Chain(1),     2: Chain(2, lattice_spacing=distance),     3: start.add_position(         [(-inv_sqrt_2_rounded, 0.0), (inv_sqrt_2_rounded, 0.0), (0, distance)]     ),     4: Square(2, lattice_spacing=distance),     7: start.add_position(         [             (0, 0),             (distance, 0),             (-0.5 * distance, distance),             (0.5 * distance, distance),             (1.5 * distance, distance),             (0, 2 * distance),             (distance, 2 * distance),         ]     ), } In\u00a0[3]: Copied! <pre>sequence = start.rydberg.rabi.amplitude.uniform.piecewise_linear(\n    durations=[\"ramp_time\", \"run_time\", \"ramp_time\"],\n    values=[0.0, \"rabi_drive\", \"rabi_drive\", 0.0],\n).parse_sequence()\n</pre> sequence = start.rydberg.rabi.amplitude.uniform.piecewise_linear(     durations=[\"ramp_time\", \"run_time\", \"ramp_time\"],     values=[0.0, \"rabi_drive\", \"rabi_drive\", 0.0], ).parse_sequence() In\u00a0[4]: Copied! <pre>batch = (\n    geometries[7]\n    .apply(sequence)\n    .assign(ramp_time=0.06, rabi_drive=5)\n    .batch_assign(run_time=0.05 * np.arange(21))\n)\n</pre> batch = (     geometries[7]     .apply(sequence)     .assign(ramp_time=0.06, rabi_drive=5)     .batch_assign(run_time=0.05 * np.arange(21)) ) In\u00a0[5]: Copied! <pre>emu_filename = os.path.join(\n    os.path.abspath(\"\"), \"data\", \"multi-qubit-blockaded-emulation.json\"\n)\n\nif not os.path.isfile(emu_filename):\n    emu_batch = batch.bloqade.python().run(10000, interaction_picture=True)\n    save(emu_batch, emu_filename)\n\nfilename = os.path.join(os.path.abspath(\"\"), \"data\", \"multi-qubit-blockaded-job.json\")\n\nif not os.path.isfile(filename):\n    hardware_batch = batch.parallelize(24).braket.aquila().run_async(shots=100)\n    save(hardware_batch, filename)\n</pre>  emu_filename = os.path.join(     os.path.abspath(\"\"), \"data\", \"multi-qubit-blockaded-emulation.json\" )  if not os.path.isfile(emu_filename):     emu_batch = batch.bloqade.python().run(10000, interaction_picture=True)     save(emu_batch, emu_filename)  filename = os.path.join(os.path.abspath(\"\"), \"data\", \"multi-qubit-blockaded-job.json\")  if not os.path.isfile(filename):     hardware_batch = batch.parallelize(24).braket.aquila().run_async(shots=100)     save(hardware_batch, filename) In\u00a0[6]: Copied! <pre>emu_batch = load(emu_filename)\nhardware_batch = load(filename)\n# hardware_batch.fetch()\n# save(filename, hardware_batch)\n</pre> emu_batch = load(emu_filename) hardware_batch = load(filename) # hardware_batch.fetch() # save(filename, hardware_batch) <p>The quantity of interest here is the total Rydberg density of the cluster defined as the sum of the Rydberg densities of each atom. We can extract this from the results and plot it as a function of time. We will do this for both the emulator and the hardware. We can use the <code>rydberg_densities</code> function to extract the densities from the <code>Report</code> of the <code>batch</code> object.</p> In\u00a0[7]: Copied! <pre>emu_report = emu_batch.report()\nemu_densities = emu_report.rydberg_densities()\nemu_densities_summed = emu_densities.sum(axis=1)\n\nhardware_report = hardware_batch.report()\nhardware_densities = hardware_report.rydberg_densities()\nhardware_densities_summed = hardware_densities.sum(axis=1)\n\n\nemu_run_times = emu_report.list_param(\"run_time\")\nhw_run_times = hardware_report.list_param(\"run_time\")\n\nfig, ax = plt.subplots()\nax.set_xlabel(\"Time\")\nax.set_ylabel(\"Sum of Rydberg Densities\")\n# emulation\nax.plot(emu_run_times, emu_densities_summed, label=\"Emulator\", color=\"#878787\")\n# hardware\nax.plot(hw_run_times, hardware_densities_summed, label=\"QPU\", color=\"#6437FF\")\nax.legend()\nax.set_xlabel(\"Time ($\\mu s$)\")\nax.set_ylabel(\"Sum of Rydberg Densities\")\nplt.show()\n</pre>  emu_report = emu_batch.report() emu_densities = emu_report.rydberg_densities() emu_densities_summed = emu_densities.sum(axis=1)  hardware_report = hardware_batch.report() hardware_densities = hardware_report.rydberg_densities() hardware_densities_summed = hardware_densities.sum(axis=1)   emu_run_times = emu_report.list_param(\"run_time\") hw_run_times = hardware_report.list_param(\"run_time\")  fig, ax = plt.subplots() ax.set_xlabel(\"Time\") ax.set_ylabel(\"Sum of Rydberg Densities\") # emulation ax.plot(emu_run_times, emu_densities_summed, label=\"Emulator\", color=\"#878787\") # hardware ax.plot(hw_run_times, hardware_densities_summed, label=\"QPU\", color=\"#6437FF\") ax.legend() ax.set_xlabel(\"Time ($\\mu s$)\") ax.set_ylabel(\"Sum of Rydberg Densities\") plt.show() <pre>&lt;&gt;:21: SyntaxWarning: invalid escape sequence '\\m'\n&lt;&gt;:21: SyntaxWarning: invalid escape sequence '\\m'\n/tmp/ipykernel_2179/1634389853.py:21: SyntaxWarning: invalid escape sequence '\\m'\n  ax.set_xlabel(\"Time ($\\mu s$)\")\n</pre>"},{"location":"examples/example-2-multi-qubit-blockaded/#multi-qubit-blockaded-rabi-oscillations","title":"Multi-qubit Blockaded Rabi Oscillations\u00b6","text":""},{"location":"examples/example-2-multi-qubit-blockaded/#introduction","title":"Introduction\u00b6","text":"<p>In this tutorial we will show you how to compose geometries with pulse sequences to perform multi-qubit blockaded Rabi oscillations. The Physics here is described in detail in the whitepaper. But in short, we can use the Rydberg blockade to change the effective Rabi frequency of the entire system by adding more atoms to the cluster.</p>"},{"location":"examples/example-2-multi-qubit-blockaded/#defining-the-geometry","title":"Defining the Geometry\u00b6","text":"<p>We will start by defining the geometry of the atoms. The idea here is to cluster the atoms so that they are all blockaded from each other. Using a combination of the <code>Chain</code> and <code>Square</code> classes, as a base, one can add additional atoms to the geometry using the <code>add_position</code> method. This method takes a list of tuples, or a single tuple, of the form <code>(x,y)</code> where <code>x</code> and <code>y</code> are the coordinates of the atom in units of the lattice constant.</p>"},{"location":"examples/example-2-multi-qubit-blockaded/#defining-the-pulse-sequence","title":"Defining the Pulse Sequence\u00b6","text":"<p>Next, we will define the pulse sequence. We start from the <code>start</code> object, which is an empty list of atom locations. In this case, we do not need atoms to build the pulse sequence, but to extract the sequence, we need to call the <code>parse_sequence</code> method. This creates a <code>Sequence</code> object that we can apply to multiple geometries.</p>"},{"location":"examples/example-2-multi-qubit-blockaded/#defining-the-program","title":"Defining the Program\u00b6","text":"<p>Now, all that is left to do is to compose the geometry and the Pulse sequence into a fully defined program. We can do this by calling the <code>apply</code> method on the geometry and passing in the sequence. This method will return an object that can then be assigned parameters.</p>"},{"location":"examples/example-2-multi-qubit-blockaded/#run-emulator-and-hardware","title":"Run Emulator and Hardware\u00b6","text":"<p>Again, we run the program on the emulator and Aquila and save the results to a file so we can use them later.</p> <p>Hardware Execution Cost</p> <p> <p>For this particular program, 21 tasks are generated with each task having 100 shots, amounting to USD \\$27.30 on AWS Braket.</p> </p>"},{"location":"examples/example-2-multi-qubit-blockaded/#plotting-the-results","title":"Plotting the Results\u00b6","text":"<p>First, we load the results from the file.</p>"},{"location":"examples/example-2-nonequilibrium-dynamics-blockade-radius/","title":"Nonequilibrium Dynamics of nearly Blockaded Rydberg Atoms","text":"<p> Download Script   Download Job </p> <p>Job Files for Complete Examples</p> <p> To be able to run the complete examples without having to submit your program to hardware and wait, you'll need to download the associated job files. These files contain the results of running the program on the quantum hardware.  <p>You can download the job files by clicking the \"Download Job\" button above. You'll then need to place the job file in the <code>data</code> directory that was created for you when you ran the <code>import</code> part of the script (alternatively you can make the directory yourself, it should live at the same level as wherever you put this script).</p> </p> In\u00a0[1]: Copied! <pre>import os\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom bloqade.analog import load, save\nfrom bloqade.analog.atom_arrangement import Chain\n\nif not os.path.isdir(\"data\"):\n    os.mkdir(\"data\")\n</pre>  import os  import numpy as np import matplotlib.pyplot as plt from bloqade.analog import load, save from bloqade.analog.atom_arrangement import Chain  if not os.path.isdir(\"data\"):     os.mkdir(\"data\") In\u00a0[2]: Copied! <pre>initial_geometry = Chain(2, lattice_spacing=\"distance\")\nprogram_waveforms = initial_geometry.rydberg.rabi.amplitude.uniform.piecewise_linear(\n    durations=[\"ramp_time\", \"run_time\", \"ramp_time\"],\n    values=[0.0, \"rabi_ampl\", \"rabi_ampl\", 0.0],\n)\nprogram_assigned_vars = program_waveforms.assign(\n    ramp_time=0.06, rabi_ampl=15, distance=8.5\n)\nbatch = program_assigned_vars.batch_assign(run_time=0.05 * np.arange(31))\n</pre>  initial_geometry = Chain(2, lattice_spacing=\"distance\") program_waveforms = initial_geometry.rydberg.rabi.amplitude.uniform.piecewise_linear(     durations=[\"ramp_time\", \"run_time\", \"ramp_time\"],     values=[0.0, \"rabi_ampl\", \"rabi_ampl\", 0.0], ) program_assigned_vars = program_waveforms.assign(     ramp_time=0.06, rabi_ampl=15, distance=8.5 ) batch = program_assigned_vars.batch_assign(run_time=0.05 * np.arange(31)) In\u00a0[3]: Copied! <pre>emu_filename = os.path.join(\n    os.path.abspath(\"\"), \"data\", \"nonequilibrium-dynamics-blockade-emulation.json\"\n)\nif not os.path.isfile(emu_filename):\n    emu_batch = batch.bloqade.python().run(10000)\n    save(emu_batch, emu_filename)\n</pre> emu_filename = os.path.join(     os.path.abspath(\"\"), \"data\", \"nonequilibrium-dynamics-blockade-emulation.json\" ) if not os.path.isfile(emu_filename):     emu_batch = batch.bloqade.python().run(10000)     save(emu_batch, emu_filename) <p>When running on the hardware we will also parallelize the batch and submit.</p> <p>Hardware Execution Cost</p> <p> <p>For this particular program, 31 tasks are generated with each task having 100 shots, amounting to USD \\$40.30 on AWS Braket.</p> </p> In\u00a0[4]: Copied! <pre>filename = os.path.join(\n    os.path.abspath(\"\"), \"data\", \"nonequilibrium-dynamics-blockade-job.json\"\n)\n\nif not os.path.isfile(filename):\n    hardware_batch = batch.parallelize(24).braket.aquila().run_async(shots=100)\n    save(hardware_batch, filename)\n</pre> filename = os.path.join(     os.path.abspath(\"\"), \"data\", \"nonequilibrium-dynamics-blockade-job.json\" )  if not os.path.isfile(filename):     hardware_batch = batch.parallelize(24).braket.aquila().run_async(shots=100)     save(hardware_batch, filename) In\u00a0[5]: Copied! <pre>def rydberg_state_probabilities(shot_counts):\n    probabilities_dict = {\"0\": [], \"1\": [], \"2\": []}\n\n    # iterate over each of the task results\n    for task_result in shot_counts:\n        # get total number of shots\n        total_shots = sum(task_result.values())\n        # get probability of each state\n        probabilities_dict[\"0\"].append(task_result.get(\"11\", 0) / total_shots)\n        probabilities_dict[\"1\"].append(\n            (task_result.get(\"10\", 0) + task_result.get(\"01\", 0)) / total_shots\n        )\n        probabilities_dict[\"2\"].append(task_result.get(\"00\", 0) / total_shots)\n\n    return probabilities_dict\n</pre> def rydberg_state_probabilities(shot_counts):     probabilities_dict = {\"0\": [], \"1\": [], \"2\": []}      # iterate over each of the task results     for task_result in shot_counts:         # get total number of shots         total_shots = sum(task_result.values())         # get probability of each state         probabilities_dict[\"0\"].append(task_result.get(\"11\", 0) / total_shots)         probabilities_dict[\"1\"].append(             (task_result.get(\"10\", 0) + task_result.get(\"01\", 0)) / total_shots         )         probabilities_dict[\"2\"].append(task_result.get(\"00\", 0) / total_shots)      return probabilities_dict In\u00a0[6]: Copied! <pre>emu_batch = load(emu_filename)\nemu_report = emu_batch.report()\nemu_counts = emu_report.counts()\n\nhardware_batch = load(filename)\n# hardware_batch.fetch() # uncomment to fetch results from Braket\n# save(filename, hardware_batch)\n</pre>  emu_batch = load(emu_filename) emu_report = emu_batch.report() emu_counts = emu_report.counts()  hardware_batch = load(filename) # hardware_batch.fetch() # uncomment to fetch results from Braket # save(filename, hardware_batch) <p>To get the <code>counts</code> we need to get a <code>report</code> from the <code>batch</code> objects. Then with the report we can get the counts. The counts are a dictionary that maps the bitstring to the number of times that bitstring was measured.</p> In\u00a0[7]: Copied! <pre>emu_report = emu_batch.report()\nhardware_report = hardware_batch.report()\n\n\nemu_rydberg_state_probabilities = rydberg_state_probabilities(emu_report.counts())\nhw_rydberg_state_probabilities = rydberg_state_probabilities(hardware_report.counts())\n</pre>  emu_report = emu_batch.report() hardware_report = hardware_batch.report()   emu_rydberg_state_probabilities = rydberg_state_probabilities(emu_report.counts()) hw_rydberg_state_probabilities = rydberg_state_probabilities(hardware_report.counts()) <p>plot 0, 1, and 2 Rydberg state probabilities but in separate plots</p> In\u00a0[8]: Copied! <pre>figure, axs = plt.subplots(1, 3, figsize=(12, 6), sharey=True)\n\nemu_run_times = emu_report.list_param(\"run_time\")\nhardware_run_times = hardware_report.list_param(\"run_time\")\n\nemu_colors = [\"#55DE79\", \"#EDFF1A\", \"#C2477F\"]  # Green, Yellow, Red\n\nemu_lines = []\nhw_lines = []\nfor ax, rydberg_state, color in zip(axs, [\"0\", \"1\", \"2\"], emu_colors):\n    (hw_line,) = ax.plot(\n        emu_run_times,\n        hw_rydberg_state_probabilities[rydberg_state],\n        label=rydberg_state + \"-Rydberg QPU\",\n        color=color,\n    )\n    (emu_line,) = ax.plot(\n        hardware_run_times,\n        emu_rydberg_state_probabilities[rydberg_state],\n        color=\"#878787\",\n    )\n    emu_line.set_label(\"Emulator\")\n\n    emu_lines.append(emu_line)\n    hw_lines.append(hw_line)\n\n    ax.set_xlabel(\"time ($\\mu s$)\")\n    ax.set_ylabel(\"Probability\")\n\nax.legend(handles=[*hw_lines, emu_lines[-1]])\n\nplt.show()\n</pre> figure, axs = plt.subplots(1, 3, figsize=(12, 6), sharey=True)  emu_run_times = emu_report.list_param(\"run_time\") hardware_run_times = hardware_report.list_param(\"run_time\")  emu_colors = [\"#55DE79\", \"#EDFF1A\", \"#C2477F\"]  # Green, Yellow, Red  emu_lines = [] hw_lines = [] for ax, rydberg_state, color in zip(axs, [\"0\", \"1\", \"2\"], emu_colors):     (hw_line,) = ax.plot(         emu_run_times,         hw_rydberg_state_probabilities[rydberg_state],         label=rydberg_state + \"-Rydberg QPU\",         color=color,     )     (emu_line,) = ax.plot(         hardware_run_times,         emu_rydberg_state_probabilities[rydberg_state],         color=\"#878787\",     )     emu_line.set_label(\"Emulator\")      emu_lines.append(emu_line)     hw_lines.append(hw_line)      ax.set_xlabel(\"time ($\\mu s$)\")     ax.set_ylabel(\"Probability\")  ax.legend(handles=[*hw_lines, emu_lines[-1]])  plt.show() <pre>&lt;&gt;:27: SyntaxWarning: invalid escape sequence '\\m'\n&lt;&gt;:27: SyntaxWarning: invalid escape sequence '\\m'\n/tmp/ipykernel_2207/2519760216.py:27: SyntaxWarning: invalid escape sequence '\\m'\n  ax.set_xlabel(\"time ($\\mu s$)\")\n</pre>"},{"location":"examples/example-2-nonequilibrium-dynamics-blockade-radius/#nonequilibrium-dynamics-of-nearly-blockaded-rydberg-atoms","title":"Nonequilibrium Dynamics of nearly Blockaded Rydberg Atoms\u00b6","text":""},{"location":"examples/example-2-nonequilibrium-dynamics-blockade-radius/#introduction","title":"Introduction\u00b6","text":"<p>In this example we will show how to generate multi-atom programs looking specifically at the dynamics of two atoms that are right on the blockade radius. First let's start with the imports.</p>"},{"location":"examples/example-2-nonequilibrium-dynamics-blockade-radius/#program-definition","title":"Program Definition\u00b6","text":"<p>We will start by defining a program. We set up a chain of two atoms with a parameterized distance between them. We then define a Rabi like in the original Rabi oscillation example. Given a <code>rabi_ampl</code> of 15 rad/\u00b5s the blockaded radius s 8.44 \u00b5m. We will look at the dynamics of the system for a distance of 8.5 \u00b5m to be every so slightly outside of the blockade radius. We then define a <code>batch</code> of programs for different <code>run_time</code> values.</p>"},{"location":"examples/example-2-nonequilibrium-dynamics-blockade-radius/#run-emulator-and-hardware","title":"Run Emulator and Hardware\u00b6","text":"<p>Once again we will run the emulator and hardware. We will use the <code>local_emulator</code> method to run the emulator locally. We will then save the results to a file so that we can use them later.</p>"},{"location":"examples/example-2-nonequilibrium-dynamics-blockade-radius/#plotting-the-results","title":"Plotting the Results\u00b6","text":"<p>In order to show the complex dynamics we will plot the probability of having <code>0</code>, <code>1</code> , or <code>2</code> Rydberg atoms as a function of time. We will do this for both the emulator and the hardware. We can use the <code>rydberg_state_probabilities</code> function to extract the probabilities from the counts. This function takes a list of counts and returns a dictionary of probabilities for each state. The counts are obtained from the <code>report</code> of the <code>batch</code> object.</p>"},{"location":"examples/example-2-nonequilibrium-dynamics-blockade-radius/#extracting-the-counts-and-probabilities","title":"Extracting the counts and probabilities\u00b6","text":"<p>We will now extract the counts and probabilities from the emulator and hardware runs. We will then plot the results. First we load the data from the files.</p>"},{"location":"examples/example-2-two-qubit-adiabatic/","title":"Two Qubit Adiabatic Sweep","text":"<p> Download Script   Download Job </p> <p>Job Files for Complete Examples</p> <p> To be able to run the complete examples without having to submit your program to hardware and wait, you'll need to download the associated job files. These files contain the results of running the program on the quantum hardware.  <p>You can download the job files by clicking the \"Download Job\" button above. You'll then need to place the job file in the <code>data</code> directory that was created for you when you ran the <code>import</code> part of the script (alternatively you can make the directory yourself, it should live at the same level as wherever you put this script).</p> </p> In\u00a0[1]: Copied! <pre>import os\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom bloqade.analog import var, cast, load, save, start\n\nif not os.path.isdir(\"data\"):\n    os.mkdir(\"data\")\n</pre> import os  import numpy as np import matplotlib.pyplot as plt from bloqade.analog import var, cast, load, save, start  if not os.path.isdir(\"data\"):     os.mkdir(\"data\") In\u00a0[2]: Copied! <pre>detuning_value = var(\"detuning_value\")\ndurations = cast([\"ramp_time\", \"run_time\", \"ramp_time\"])\nprog = (\n    start.add_position([(0, 0), (0, \"atom_distance\")])\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(\n        durations=durations, values=[0, \"rabi_value\", \"rabi_value\", 0]\n    )\n    .detuning.uniform.piecewise_linear(\n        durations=durations,\n        values=[\n            -detuning_value,\n            -detuning_value,\n            detuning_value,\n            detuning_value,\n        ],\n    )\n)\n\ndistances = np.arange(4, 11, 1)\nbatch = prog.assign(\n    ramp_time=1.0, run_time=2.0, rabi_value=15.0, detuning_value=15.0\n).batch_assign(atom_distance=distances)\n</pre>  detuning_value = var(\"detuning_value\") durations = cast([\"ramp_time\", \"run_time\", \"ramp_time\"]) prog = (     start.add_position([(0, 0), (0, \"atom_distance\")])     .rydberg.rabi.amplitude.uniform.piecewise_linear(         durations=durations, values=[0, \"rabi_value\", \"rabi_value\", 0]     )     .detuning.uniform.piecewise_linear(         durations=durations,         values=[             -detuning_value,             -detuning_value,             detuning_value,             detuning_value,         ],     ) )  distances = np.arange(4, 11, 1) batch = prog.assign(     ramp_time=1.0, run_time=2.0, rabi_value=15.0, detuning_value=15.0 ).batch_assign(atom_distance=distances) In\u00a0[3]: Copied! <pre># get emulation batch, running 1000 shots per task\nemu_filename = os.path.join(\n    os.path.abspath(\"\"), \"data\", \"two-qubit-adiabatic-emulation.json\"\n)\n\nif not os.path.isfile(emu_filename):\n    emu_batch = batch.bloqade.python().run(1000)\n    save(emu_batch, emu_filename)\n</pre> # get emulation batch, running 1000 shots per task emu_filename = os.path.join(     os.path.abspath(\"\"), \"data\", \"two-qubit-adiabatic-emulation.json\" )  if not os.path.isfile(emu_filename):     emu_batch = batch.bloqade.python().run(1000)     save(emu_batch, emu_filename) <p>Then, we can run the program on the hardware after parallelizing the tasks. We can then save the results to a file.</p> <p>Hardware Execution Cost</p> <p> <p>For this particular program, 7 tasks are generated with each task having 100 shots, amounting to USD \\$9.10 on AWS Braket.</p> </p> In\u00a0[4]: Copied! <pre>filename = os.path.join(os.path.abspath(\"\"), \"data\", \"two-qubit-adiabatic-job.json\")\n\nif not os.path.isfile(filename):\n    hardware_batch = batch.parallelize(24).braket.aquila().run_async(shots=100)\n    save(hardware_batch, filename)\n</pre>  filename = os.path.join(os.path.abspath(\"\"), \"data\", \"two-qubit-adiabatic-job.json\")  if not os.path.isfile(filename):     hardware_batch = batch.parallelize(24).braket.aquila().run_async(shots=100)     save(hardware_batch, filename) In\u00a0[5]: Copied! <pre>def rydberg_state_probabilities(emu_counts):\n    probabilities_dict = {\"0\": [], \"1\": [], \"2\": []}\n\n    # iterate over each of the task results\n    for task_result in emu_counts:\n        # get total number of shots\n        total_shots = sum(task_result.values())\n        # get probability of each state\n        probabilities_dict[\"0\"].append(task_result.get(\"11\", 0) / total_shots)\n        probabilities_dict[\"1\"].append(\n            (task_result.get(\"10\", 0) + task_result.get(\"01\", 0)) / total_shots\n        )\n        probabilities_dict[\"2\"].append(task_result.get(\"00\", 0) / total_shots)\n\n    return probabilities_dict\n</pre> def rydberg_state_probabilities(emu_counts):     probabilities_dict = {\"0\": [], \"1\": [], \"2\": []}      # iterate over each of the task results     for task_result in emu_counts:         # get total number of shots         total_shots = sum(task_result.values())         # get probability of each state         probabilities_dict[\"0\"].append(task_result.get(\"11\", 0) / total_shots)         probabilities_dict[\"1\"].append(             (task_result.get(\"10\", 0) + task_result.get(\"01\", 0)) / total_shots         )         probabilities_dict[\"2\"].append(task_result.get(\"00\", 0) / total_shots)      return probabilities_dict <p>Before we can plot the results we need to load the data from the files.</p> In\u00a0[6]: Copied! <pre># get emulation report and number of shots per each state\nemu_batch = load(emu_filename)\n\n# get hardware report and number of shots per each state\nhardware_batch = load(filename)\n# hardware_batch.fetch()\n# save(hardware_batch, filename)\n</pre>  # get emulation report and number of shots per each state emu_batch = load(emu_filename)  # get hardware report and number of shots per each state hardware_batch = load(filename) # hardware_batch.fetch() # save(hardware_batch, filename) <p>We can use the <code>rydberg_state_probabilities</code> function to extract the probabilities from the counts. This function takes a list of counts and returns a dictionary of probabilities for each state. The counts are obtained from the <code>report</code> of the <code>batch</code> object.</p> <p>Now, we can plot the results!</p> In\u00a0[7]: Copied! <pre>emu_report = emu_batch.report()\nhardware_report = hardware_batch.report()\n\nemu_rydberg_state_probabilities = rydberg_state_probabilities(emu_report.counts())\nhw_rydberg_state_probabilities = rydberg_state_probabilities(hardware_report.counts())\n\nemu_distances = emu_report.list_param(\"atom_distance\")\nhw_distances = hardware_report.list_param(\"atom_distance\")\n\nfig, ax = plt.subplots()\nemu_colors = [\"#55DE79\", \"#EDFF1A\", \"#C2477F\"]  # Green, Yellow, Red\n\nemu_lines = []\nhw_lines = []\nfor rydberg_state, color in zip([\"0\", \"1\", \"2\"], emu_colors):\n    (hw_line,) = ax.plot(\n        emu_distances,\n        hw_rydberg_state_probabilities[rydberg_state],\n        label=rydberg_state + \"-Rydberg QPU\",\n        color=color,\n    )\n    (emu_line,) = ax.plot(\n        hw_distances,\n        emu_rydberg_state_probabilities[rydberg_state],\n        color=\"#878787\",\n        label=\"Emulator\",\n    )\n\n    emu_lines.append(emu_line)\n    hw_lines.append(hw_line)\n\n\nax.legend(handles=[*hw_lines, emu_lines[-1]])\nax.set_xlabel(\"time ($\\mu s$)\")\nax.set_ylabel(\"Probability\")\nfig.show()\n</pre>  emu_report = emu_batch.report() hardware_report = hardware_batch.report()  emu_rydberg_state_probabilities = rydberg_state_probabilities(emu_report.counts()) hw_rydberg_state_probabilities = rydberg_state_probabilities(hardware_report.counts())  emu_distances = emu_report.list_param(\"atom_distance\") hw_distances = hardware_report.list_param(\"atom_distance\")  fig, ax = plt.subplots() emu_colors = [\"#55DE79\", \"#EDFF1A\", \"#C2477F\"]  # Green, Yellow, Red  emu_lines = [] hw_lines = [] for rydberg_state, color in zip([\"0\", \"1\", \"2\"], emu_colors):     (hw_line,) = ax.plot(         emu_distances,         hw_rydberg_state_probabilities[rydberg_state],         label=rydberg_state + \"-Rydberg QPU\",         color=color,     )     (emu_line,) = ax.plot(         hw_distances,         emu_rydberg_state_probabilities[rydberg_state],         color=\"#878787\",         label=\"Emulator\",     )      emu_lines.append(emu_line)     hw_lines.append(hw_line)   ax.legend(handles=[*hw_lines, emu_lines[-1]]) ax.set_xlabel(\"time ($\\mu s$)\") ax.set_ylabel(\"Probability\") fig.show() <pre>&lt;&gt;:34: SyntaxWarning: invalid escape sequence '\\m'\n&lt;&gt;:34: SyntaxWarning: invalid escape sequence '\\m'\n/tmp/ipykernel_2244/3713733290.py:34: SyntaxWarning: invalid escape sequence '\\m'\n  ax.set_xlabel(\"time ($\\mu s$)\")\n</pre>"},{"location":"examples/example-2-two-qubit-adiabatic/#two-qubit-adiabatic-sweep","title":"Two Qubit Adiabatic Sweep\u00b6","text":""},{"location":"examples/example-2-two-qubit-adiabatic/#introduction","title":"Introduction\u00b6","text":"<p>In this example, we show how to use Bloqade to program an adiabatic sweep on a pair of atoms, with the distance between atoms gradually increasing per task. This will allow us to explore the effect of the Rydberg interaction. We will run the program on both the emulator and the hardware to compare the results.</p>"},{"location":"examples/example-2-two-qubit-adiabatic/#defining-the-program","title":"Defining the Program\u00b6","text":"<p>Now, we define our program of interest. For an adiabatic protocol, we keep that Rabi frequency at a considerable value while slowly ramping the detuning from a large negative to a positive value. The idea is that when the detuning is large and negative the atoms remain in the ground state. As the detuning is ramped to positive values, the atoms are able to be excited to the Rydberg state, however if the atoms are too close together, the Rydberg interactions effectively acts like a negative detuning to neighboring atoms, preventing them from being excited. This is the blockade effect. For atoms that are sufficiently far apart, the Rydberg interaction is negligible and the atoms can be excited to the Rydberg state. As the atoms get closer together, the Rydberg interaction becomes more significant the probability of exciting both atoms becomes smaller. The typical length scale for the cross over from the non-interacting to the blockade regime is the blockade radius.</p> <p>Note that you can perform arithmetic operations directly on variables in the program but this requires the variable to be explicitly declared by passing a string to the <code>var</code> function and THEN doing arithmetic on it.</p>"},{"location":"examples/example-2-two-qubit-adiabatic/#run-on-emulator-and-hardware","title":"Run on Emulator and Hardware\u00b6","text":"<p>In previous examples, we have shown how to run a program on the emulator and hardware. First, we will run the program on the emulator and save the results to a file.</p>"},{"location":"examples/example-2-two-qubit-adiabatic/#plot-the-results","title":"Plot the Results\u00b6","text":"<p>To show the blockade effect on the system, we will plot the probability of having <code>0</code>, <code>1</code>, or <code>2</code> Rydberg atoms as a function of time. We will do this for both the emulator and the hardware. We can use the following function to get the probabilities from the shot counts of each of the different configurations of the two Rydberg atoms: <code>00</code>, <code>10</code>, <code>01</code>, and <code>11</code>. Note that <code>0</code> corresponds to the Rydberg state while <code>1</code> corresponds to the ground state. As such, <code>00</code> corresponds to two Rydberg atoms, <code>10</code>  and <code>01</code> corresponds to one Rydberg atom and one ground-state atom, and <code>11</code> corresponds to two ground-state atoms.</p>"},{"location":"examples/example-3-2d-ordered-state/","title":"2D State Preparation","text":"<p> Download Script   Download Job </p> <p>Job Files for Complete Examples</p> <p> To be able to run the complete examples without having to submit your program to hardware and wait, you'll need to download the associated job files. These files contain the results of running the program on the quantum hardware.  <p>You can download the job files by clicking the \"Download Job\" button above. You'll then need to place the job file in the <code>data</code> directory that was created for you when you ran the <code>import</code> part of the script (alternatively you can make the directory yourself, it should live at the same level as wherever you put this script).</p> </p> <p>You might notice that the tools we need to import are a lot shorter than prior instances. This is because we're taking advantage of bloqade Python's built-in visualization capabilities instead of crafting a new plot with matplotlib.</p> In\u00a0[1]: Copied! <pre>import os\n\nfrom bokeh.io import output_notebook\nfrom bloqade.analog import load, save\nfrom bloqade.analog.atom_arrangement import Square\n\nif not os.path.isdir(\"data\"):\n    os.mkdir(\"data\")\n\n# This tells Bokeh to display output in the notebook\n# versus opening a browser window\noutput_notebook()\n</pre> import os  from bokeh.io import output_notebook from bloqade.analog import load, save from bloqade.analog.atom_arrangement import Square  if not os.path.isdir(\"data\"):     os.mkdir(\"data\")  # This tells Bokeh to display output in the notebook # versus opening a browser window output_notebook() Loading BokehJS ... In\u00a0[2]: Copied! <pre># Have atoms separated by 5.9 micrometers\nL = 3\nlattice_spacing = 5.9\n\nrabi_amplitude_values = [0.0, 15.8, 15.8, 0.0]\nrabi_detuning_values = [-16.33, -16.33, \"delta_end\", \"delta_end\"]\ndurations = [0.8, \"sweep_time\", 0.8]\n\nprog = (\n    Square(L, lattice_spacing=lattice_spacing)\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(durations, rabi_amplitude_values)\n    .detuning.uniform.piecewise_linear(durations, rabi_detuning_values)\n)\n\nbatch = prog.assign(delta_end=42.66, sweep_time=2.4)\n</pre> # Have atoms separated by 5.9 micrometers L = 3 lattice_spacing = 5.9  rabi_amplitude_values = [0.0, 15.8, 15.8, 0.0] rabi_detuning_values = [-16.33, -16.33, \"delta_end\", \"delta_end\"] durations = [0.8, \"sweep_time\", 0.8]  prog = (     Square(L, lattice_spacing=lattice_spacing)     .rydberg.rabi.amplitude.uniform.piecewise_linear(durations, rabi_amplitude_values)     .detuning.uniform.piecewise_linear(durations, rabi_detuning_values) )  batch = prog.assign(delta_end=42.66, sweep_time=2.4) In\u00a0[3]: Copied! <pre>emu_filename = os.path.join(\n    os.path.abspath(\"\"), \"data\", \"striated-phase-emulation.json\"\n)\nif not os.path.isfile(emu_filename):\n    emu_future = batch.braket.local_emulator().run(shots=10000)\n    save(emu_future, emu_filename)\n\nhw_filename = os.path.join(os.path.abspath(\"\"), \"data\", \"striated-phase-hardware.json\")\nif not os.path.isfile(hw_filename):\n    future = batch.parallelize(24).braket.aquila().run_async(shots=100)\n    save(future, hw_filename)\n</pre> emu_filename = os.path.join(     os.path.abspath(\"\"), \"data\", \"striated-phase-emulation.json\" ) if not os.path.isfile(emu_filename):     emu_future = batch.braket.local_emulator().run(shots=10000)     save(emu_future, emu_filename)  hw_filename = os.path.join(os.path.abspath(\"\"), \"data\", \"striated-phase-hardware.json\") if not os.path.isfile(hw_filename):     future = batch.parallelize(24).braket.aquila().run_async(shots=100)     save(future, hw_filename) In\u00a0[4]: Copied! <pre># retrieve results from emulator and HW\nemu_batch = load(emu_filename)\nhardware_batch = load(hw_filename)\n\n# Uncomment lines below to fetch results from Braket\n# hardware_batch = hardware_batch.fetch()\n# save(hardware_batch, filename)\n</pre> # retrieve results from emulator and HW emu_batch = load(emu_filename) hardware_batch = load(hw_filename)  # Uncomment lines below to fetch results from Braket # hardware_batch = hardware_batch.fetch() # save(hardware_batch, filename) In\u00a0[5]: Copied! <pre>emu_batch.report().show()\n</pre> emu_batch.report().show() <pre>0.0 11.8 0.0 11.8\n</pre> <p>Just as before, we let Bloqade generate a <code>report</code> which contains all the results in easy to digest format but we invoke the <code>.show()</code> method of our report which us easily get an idea of the results of our experiment with interactive plots.</p> <p>The plot that mos interests us is the one on the right under the \"Rydberg Density\" section.</p> In\u00a0[6]: Copied! <pre>hardware_batch.report().show()\n</pre> hardware_batch.report().show() <pre>0.0 47.6 0.0 47.6\n</pre> <p>Considering Bloqade's goal of a uniform visualization pipeline, we can get the same ability for results from hardware. Note that we can confirm the program does what it's supposed to as results from emulation agree with those from hardware quite well.</p>"},{"location":"examples/example-3-2d-ordered-state/#2d-state-preparation","title":"2D State Preparation\u00b6","text":""},{"location":"examples/example-3-2d-ordered-state/#introduction","title":"Introduction\u00b6","text":"<p>In this example we show how to create the Striated Phase on a 2D chain of atoms.</p>"},{"location":"examples/example-3-2d-ordered-state/#program-definition","title":"Program Definition\u00b6","text":"<p>We define a program where our geometry is a square lattice of 3x3 atoms. Notice that unlike the 1D Z2 state preparation example the detuning now ramps to a higher value and the atoms are closer together.</p>"},{"location":"examples/example-3-2d-ordered-state/#submitting-to-emulator-and-hardware","title":"Submitting to Emulator and Hardware\u00b6","text":"<p>Just as in prior examples, we submit our program to both hardware and the emulator and save the intermediate data in files for convenient fetching when the results are ready from hardware, as well as avoiding having to repeat emulation runs for the purposes of analysis.</p> <p>Considering how small a 3 x 3 lattice of atoms is relative to machine capabilities, we also take advantage of parallelization to duplicate the geometry and get more data per shot when submitting to Hardware.</p> <p>Hardware Execution Cost</p> <p> <p>For this particular program, 1 task is generated with 100 shots, amounting to USD \\$1.30 on AWS Braket.</p> </p>"},{"location":"examples/example-3-2d-ordered-state/#extracting-results","title":"Extracting Results\u00b6","text":"<p>We can reload our files to get results:</p>"},{"location":"examples/example-3-2d-ordered-state/#visualizing-results-with-ease","title":"Visualizing Results With Ease\u00b6","text":"<p>In prior examples we've leverage Bloqade's ability to automatically put hardware and emulation results into the formats we need to make analysis easier.</p> <p>Now we'll go one step further by letting Bloqade Python do the visualization for us. In this case we'll visualize the Rydberg Densities of our system overlaid on the original geometry with just the following:</p>"},{"location":"examples/example-3-time-sweep/","title":"1D Z2 State Preparation","text":"<p> Download Script   Download Job </p> <p>Job Files for Complete Examples</p> <p> To be able to run the complete examples without having to submit your program to hardware and wait, you'll need to download the associated job files. These files contain the results of running the program on the quantum hardware.  <p>You can download the job files by clicking the \"Download Job\" button above. You'll then need to place the job file in the <code>data</code> directory that was created for you when you ran the <code>import</code> part of the script (alternatively you can make the directory yourself, it should live at the same level as wherever you put this script).</p> </p> <p>Let's import all the tools we'll need.</p> In\u00a0[1]: Copied! <pre>import os\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom bloqade.analog import load, save\nfrom bloqade.analog.atom_arrangement import Chain\n\nif not os.path.isdir(\"data\"):\n    os.mkdir(\"data\")\n</pre> import os  import numpy as np import matplotlib.pyplot as plt from bloqade.analog import load, save from bloqade.analog.atom_arrangement import Chain  if not os.path.isdir(\"data\"):     os.mkdir(\"data\") In\u00a0[2]: Copied! <pre># Define relevant parameters for the lattice geometry and pulse schedule\nn_atoms = 11\nlattice_spacing = 6.1\nmin_time_step = 0.05\n</pre> # Define relevant parameters for the lattice geometry and pulse schedule n_atoms = 11 lattice_spacing = 6.1 min_time_step = 0.05 <p>We choose a maximum Rabi amplitude of 15.8 MHz. Pushing the Rabi amplitude as high as we can minimizes the protocol duration, but maintains the same pulse area, $\\Omega t$. For this reason, in many cases, maximizing the Rabi frequency is considered good practice for minimizing decoherence effects.</p> In\u00a0[3]: Copied! <pre>rabi_amplitude_values = [0.0, 15.8, 15.8, 0.0]\n</pre> rabi_amplitude_values = [0.0, 15.8, 15.8, 0.0] <p>The lattice spacing and Rabi amplitudes give us a nearest neighbor interaction strength: $$V_{{i},{i+1}} = \\frac{C_6}{a^6} \\approx 105.21 \\, \\text{MHz} \\gg \\Omega = 15.8 \\, \\text{MHz}$$ where $C_6 = 2\\pi \\times 862690 \\, \\text{MHz} \\, \\mu \\text{m}^6$ is our van der Waals coefficient for Aquila hardware and $a$ is the lattice spacing we defined earlier. Our interaction strength for next-nearest neighbors is quite low comparatively: $$V_{{i},{i+2}} = \\frac{C_6}{(2a)^6} \\approx 1.64 \\, \\text{MHz} \\ll \\Omega = 15.8 \\, \\text{MHz}$$ The Rydberg interaction term dominates for nearest neighbor spacing, while the Rabi coupling dominates for next-nearest neighbors. This increases the probability of realizing a Rydberg blockade for nearest neighbors, but decreases the probability of Rydberg interaction between next-nearest neighbors. So far, we're in a good position for creating a Z2 phase.</p> <p>Next, we define our detuning values.</p> In\u00a0[4]: Copied! <pre>rabi_detuning_values = [-16.33, -16.33, 16.33, 16.33]\n</pre> rabi_detuning_values = [-16.33, -16.33, 16.33, 16.33] <p>We start at large negative detuning values where all atoms are in the ground state. Then, we transition to large positive detuning values where the Rydberg state becomes energetically favorable and inter-atomic interactions become more important.</p> <p>The maximum absolute detuning value of $16.33 \\, \\text{MHz}$ gives us a Rydberg blockade radius $$R_b = \\Bigl(\\frac{C_6}{\\sqrt{\\Delta^2+\\Omega^2}}\\Bigr)^{1/6} \\approx 7.88 \\mu \\text{m}$$ Typically, we define the lattice spacing such that $a &lt; R_b &lt; 2a$ for a good blockade approximation and Z2 state probability.</p> <p>Lastly, we define a set of test durations over which to execute our pulses and write the instructions for our program.</p> In\u00a0[5]: Copied! <pre>durations = [0.8, \"sweep_time\", 0.8]\n# Note the addition of a \"sweep_time\" variable\n# for performing sweeps of time values.\n\ntime_sweep_z2_prog = (\n    Chain(n_atoms, lattice_spacing=lattice_spacing)\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(durations, rabi_amplitude_values)\n    .detuning.uniform.piecewise_linear(durations, rabi_detuning_values)\n)\n\n# Allow \"sweep_time\" to assume values from 0.05 to 2.4 microseconds for a total of\n# 20 possible values.\n# Starting at exactly 0.0 isn't feasible so we use the `min_time_step` defined\n# previously.\ntime_sweep_z2_job = time_sweep_z2_prog.batch_assign(\n    sweep_time=np.linspace(min_time_step, 2.4, 20)\n)\n</pre> durations = [0.8, \"sweep_time\", 0.8] # Note the addition of a \"sweep_time\" variable # for performing sweeps of time values.  time_sweep_z2_prog = (     Chain(n_atoms, lattice_spacing=lattice_spacing)     .rydberg.rabi.amplitude.uniform.piecewise_linear(durations, rabi_amplitude_values)     .detuning.uniform.piecewise_linear(durations, rabi_detuning_values) )  # Allow \"sweep_time\" to assume values from 0.05 to 2.4 microseconds for a total of # 20 possible values. # Starting at exactly 0.0 isn't feasible so we use the `min_time_step` defined # previously. time_sweep_z2_job = time_sweep_z2_prog.batch_assign(     sweep_time=np.linspace(min_time_step, 2.4, 20) ) In\u00a0[6]: Copied! <pre>emu_filename = os.path.join(os.path.abspath(\"\"), \"data\", \"time-sweep-emulation.json\")\nif not os.path.isfile(emu_filename):\n    emu_future = time_sweep_z2_job.bloqade.python().run(shots=10000)\n    save(emu_future, emu_filename)\n\nfilename = os.path.join(os.path.abspath(\"\"), \"data\", \"time-sweep-job.json\")\nif not os.path.isfile(filename):\n    future = time_sweep_z2_job.parallelize(24).braket.aquila().run_async(shots=100)\n    save(future, filename)\n</pre> emu_filename = os.path.join(os.path.abspath(\"\"), \"data\", \"time-sweep-emulation.json\") if not os.path.isfile(emu_filename):     emu_future = time_sweep_z2_job.bloqade.python().run(shots=10000)     save(emu_future, emu_filename)  filename = os.path.join(os.path.abspath(\"\"), \"data\", \"time-sweep-job.json\") if not os.path.isfile(filename):     future = time_sweep_z2_job.parallelize(24).braket.aquila().run_async(shots=100)     save(future, filename) In\u00a0[7]: Copied! <pre>def get_z2_probabilities(report):\n    z2_probabilities = []\n\n    for count in report.counts():\n        z2_probability = count[\"01010101010\"] / sum(list(count.values()))\n        z2_probabilities.append(z2_probability)\n\n    return z2_probabilities\n</pre> def get_z2_probabilities(report):     z2_probabilities = []      for count in report.counts():         z2_probability = count[\"01010101010\"] / sum(list(count.values()))         z2_probabilities.append(z2_probability)      return z2_probabilities In\u00a0[8]: Copied! <pre># retrieve results from HW\nemu_batch = load(emu_filename)\nhardware_batch = load(filename)\n\n# Uncomment lines below to fetch results from Braket\n# hardware_batch = hardware_batch.fetch()\n# save(hardware_batch, filename)\n</pre> # retrieve results from HW emu_batch = load(emu_filename) hardware_batch = load(filename)  # Uncomment lines below to fetch results from Braket # hardware_batch = hardware_batch.fetch() # save(hardware_batch, filename) <p>To get the counts we need to get a report from the batch objects. Then with the report we can get the counts. The counts are a dictionary that maps the bitstring to the number of times that bitstring was measured.</p> In\u00a0[9]: Copied! <pre>emu_report = emu_batch.report()\nhardware_report = hardware_batch.report()\nemu_probabilities = get_z2_probabilities(emu_report)\nhardware_probabilities = get_z2_probabilities(hardware_report)\n\nemu_sweep_times = emu_report.list_param(\"sweep_time\")\nhardware_sweep_times = hardware_report.list_param(\"sweep_time\")\n\n\nplt.plot(emu_sweep_times, emu_probabilities, label=\"Emulator\", color=\"#878787\")\nplt.plot(hardware_sweep_times, hardware_probabilities, label=\"QPU\", color=\"#6437FF\")\n\nplt.legend()\nplt.show()\n</pre> emu_report = emu_batch.report() hardware_report = hardware_batch.report() emu_probabilities = get_z2_probabilities(emu_report) hardware_probabilities = get_z2_probabilities(hardware_report)  emu_sweep_times = emu_report.list_param(\"sweep_time\") hardware_sweep_times = hardware_report.list_param(\"sweep_time\")   plt.plot(emu_sweep_times, emu_probabilities, label=\"Emulator\", color=\"#878787\") plt.plot(hardware_sweep_times, hardware_probabilities, label=\"QPU\", color=\"#6437FF\")  plt.legend() plt.show() <p>We can also plot the emulated Z2 ordered phase for a specific sweep time. Here, we extract data for a sweep time of $0.67\\mu s$ or a total pulse duration of $2.27\\mu s$.</p> In\u00a0[10]: Copied! <pre>densities = emu_report.rydberg_densities()\nsite_indices = densities.loc[0].index.values\nrydberg_densities_67_sweep = densities.loc[5, 0:10].values\n\nplt.bar(site_indices, rydberg_densities_67_sweep, color=\"#C8447C\")\nplt.xticks(site_indices)\nplt.title(\"Z2 Phase Rydberg Densities for 2.27$\\mu$s Total Pulse Duration\")\nplt.xlabel(\"Atom Site Index\")\nplt.ylabel(\"Rydberg Density\")\n\nplt.show()\n</pre> densities = emu_report.rydberg_densities() site_indices = densities.loc[0].index.values rydberg_densities_67_sweep = densities.loc[5, 0:10].values  plt.bar(site_indices, rydberg_densities_67_sweep, color=\"#C8447C\") plt.xticks(site_indices) plt.title(\"Z2 Phase Rydberg Densities for 2.27$\\mu$s Total Pulse Duration\") plt.xlabel(\"Atom Site Index\") plt.ylabel(\"Rydberg Density\")  plt.show() <pre>&lt;&gt;:7: SyntaxWarning: invalid escape sequence '\\m'\n&lt;&gt;:7: SyntaxWarning: invalid escape sequence '\\m'\n/tmp/ipykernel_2304/2362274835.py:7: SyntaxWarning: invalid escape sequence '\\m'\n  plt.title(\"Z2 Phase Rydberg Densities for 2.27$\\mu$s Total Pulse Duration\")\n</pre> <p>Similarly, we can visualize the emulated Rydberg densities of each site index as the sweep time increases and we approach adiabatic evolution.</p> In\u00a0[11]: Copied! <pre>rydberg_densities = densities.values.transpose()\n\nim = plt.imshow(rydberg_densities)\nplt.xticks(rotation=90)\nplt.xticks(\n    [x for x in range(len(emu_sweep_times))], [round(dur, 2) for dur in emu_sweep_times]\n)\nplt.yticks(site_indices)\nplt.xlabel(\"Sweep Time ($\\mu$s)\")\nplt.ylabel(\"Atom Site Index\")\nplt.colorbar(im, shrink=0.6)\n\nplt.show()\n</pre> rydberg_densities = densities.values.transpose()  im = plt.imshow(rydberg_densities) plt.xticks(rotation=90) plt.xticks(     [x for x in range(len(emu_sweep_times))], [round(dur, 2) for dur in emu_sweep_times] ) plt.yticks(site_indices) plt.xlabel(\"Sweep Time ($\\mu$s)\") plt.ylabel(\"Atom Site Index\") plt.colorbar(im, shrink=0.6)  plt.show() <pre>&lt;&gt;:9: SyntaxWarning: invalid escape sequence '\\m'\n&lt;&gt;:9: SyntaxWarning: invalid escape sequence '\\m'\n/tmp/ipykernel_2304/1397499243.py:9: SyntaxWarning: invalid escape sequence '\\m'\n  plt.xlabel(\"Sweep Time ($\\mu$s)\")\n</pre>"},{"location":"examples/example-3-time-sweep/#1d-z2-state-preparation","title":"1D Z2 State Preparation\u00b6","text":""},{"location":"examples/example-3-time-sweep/#introduction","title":"Introduction\u00b6","text":"<p>In this example we show how to create the Z2 ordered phase on a 1D chain of atoms and how to perform a scan over the sweep time to understand the behavior of an adiabatic sweep and the effect of the Rydberg blockade on a many-body system.</p>"},{"location":"examples/example-3-time-sweep/#program-definition","title":"Program Definition\u00b6","text":"<p>We define a program where our geometry is a chain of 11 atoms with a distance of 6.1 micrometers between atoms.</p> <p>The pulse schedule presented here should be reminiscent of the Two Qubit Adiabatic Sweep example although we've opted to reserve variable usage for values that will actually have their parameters swept.</p>"},{"location":"examples/example-3-time-sweep/#running-on-the-emulator-and-hardware","title":"Running on the Emulator and Hardware\u00b6","text":"<p>With our program properly composed we can now easily send it off to both the emulator and hardware.</p> <p>We select the Braket emulator and tell it that for each variation of the \"time_sweep\" variable we'd like to run 10000 shots. For the hardware we take advantage of the fact that 11 atoms takes up so little space on the machine we can duplicate that geometry multiple times to get more data per shot. We set a distance of 24 micrometers between copies to minimize potential interactions between them.</p> <p>For both cases, to allow us to submit our program without having to wait on immediate results from hardware (which could take a while considering queueing and window restrictions), we save the necessary metadata to a file that can then be reloaded later and results fetched when they are available.</p> <p>Hardware Execution Cost</p> <p> <p>For this particular program, 20 tasks are generated with each task having 100 shots, amounting to USD \\$26.00 on AWS Braket.</p> </p>"},{"location":"examples/example-3-time-sweep/#plotting-the-results","title":"Plotting the Results\u00b6","text":"<p>To make our lives easier we define a trivial function to extract the probability of the Z2 phase from each of the tasks generated from the parameter sweep. The counts are obtained from the <code>report</code>of the batch object.</p>"},{"location":"examples/example-3-time-sweep/#extracting-counts-and-probabilities","title":"Extracting Counts And Probabilities\u00b6","text":"<p>We will now extract the counts and probabilities from the emulator and hardware runs. We will then plot the results. First we load the data from the files:</p>"},{"location":"examples/example-3-time-sweep/#analysis","title":"Analysis\u00b6","text":"<p>As expected, we see that if we allow the pulse schedule to run for a longer and longer period of time (more \"adiabatically\") we have an increasing probability of creating the Z2 phase.</p>"},{"location":"examples/example-4-quantum-scar-dynamics/","title":"Quantum Scar Dynamics","text":"<p> Download Script   Download Job </p> <p>Job Files for Complete Examples</p> <p> To be able to run the complete examples without having to submit your program to hardware and wait, you'll need to download the associated job files. These files contain the results of running the program on the quantum hardware.  <p>You can download the job files by clicking the \"Download Job\" button above. You'll then need to place the job file in the <code>data</code> directory that was created for you when you ran the <code>import</code> part of the script (alternatively you can make the directory yourself, it should live at the same level as wherever you put this script).</p> </p> In\u00a0[1]: Copied! <pre>import os\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom bloqade.analog import var, load, save\nfrom bloqade.analog.atom_arrangement import Chain\n\nif not os.path.isdir(\"data\"):\n    os.mkdir(\"data\")\n\nn_atoms = 11\nlattice_spacing = 6.1\nrun_time = var(\"run_time\")\n\nquantum_scar_program = (\n    Chain(n_atoms, lattice_spacing=lattice_spacing)\n    # define detuning waveform\n    .rydberg.detuning.uniform.piecewise_linear(\n        [0.3, 1.6, 0.3], [-18.8, -18.8, 16.3, 16.3]\n    )\n    .piecewise_linear([0.2, 1.6], [16.3, 0.0, 0.0])\n    # slice the detuning waveform\n    .slice(start=0, stop=run_time)\n    # define rabi waveform\n    .amplitude.uniform.piecewise_linear([0.3, 1.6, 0.3], [0.0, 15.7, 15.7, 0.0])\n    .piecewise_linear([0.2, 1.4, 0.2], [0, 15.7, 15.7, 0])\n    # slice waveform, add padding for the linear segment\n    .slice(start=0, stop=run_time - 0.065)\n    # record the value of the waveform at the end of the slice to \"rabi_value\"\n    .record(\"rabi_value\")\n    # append segment to waveform that fixes the value of the waveform to 0\n    # at the end of the waveform\n    .linear(\"rabi_value\", 0, 0.065)\n)\n\n# get run times via the following:\nprep_times = np.arange(0.2, 2.2, 0.2)\nscar_times = np.arange(2.2, 4.01, 0.01)\nrun_times = np.unique(np.hstack((prep_times, scar_times)))\n\nbatch = quantum_scar_program.batch_assign(run_time=run_times)\n</pre>  import os  import numpy as np import matplotlib.pyplot as plt from bloqade.analog import var, load, save from bloqade.analog.atom_arrangement import Chain  if not os.path.isdir(\"data\"):     os.mkdir(\"data\")  n_atoms = 11 lattice_spacing = 6.1 run_time = var(\"run_time\")  quantum_scar_program = (     Chain(n_atoms, lattice_spacing=lattice_spacing)     # define detuning waveform     .rydberg.detuning.uniform.piecewise_linear(         [0.3, 1.6, 0.3], [-18.8, -18.8, 16.3, 16.3]     )     .piecewise_linear([0.2, 1.6], [16.3, 0.0, 0.0])     # slice the detuning waveform     .slice(start=0, stop=run_time)     # define rabi waveform     .amplitude.uniform.piecewise_linear([0.3, 1.6, 0.3], [0.0, 15.7, 15.7, 0.0])     .piecewise_linear([0.2, 1.4, 0.2], [0, 15.7, 15.7, 0])     # slice waveform, add padding for the linear segment     .slice(start=0, stop=run_time - 0.065)     # record the value of the waveform at the end of the slice to \"rabi_value\"     .record(\"rabi_value\")     # append segment to waveform that fixes the value of the waveform to 0     # at the end of the waveform     .linear(\"rabi_value\", 0, 0.065) )  # get run times via the following: prep_times = np.arange(0.2, 2.2, 0.2) scar_times = np.arange(2.2, 4.01, 0.01) run_times = np.unique(np.hstack((prep_times, scar_times)))  batch = quantum_scar_program.batch_assign(run_time=run_times) In\u00a0[2]: Copied! <pre>emu_filename = os.path.join(\n    os.path.abspath(\"\"), \"data\", \"quantum-scar-dynamics-emulation.json\"\n)\n\nif not os.path.isfile(emu_filename):\n    emu_batch = batch.bloqade.python().run(1000)\n    save(emu_batch, emu_filename)\n\n\nfilename = os.path.join(os.path.abspath(\"\"), \"data\", \"quantum-scar-dynamics-job.json\")\n\nif not os.path.isfile(filename):\n    hardware_batch = (\n        batch.parallelize(24)\n        .braket.aquila()\n        .run_async(100, ignore_submission_error=True)\n    )\n    save(hardware_batch, filename)\n</pre>  emu_filename = os.path.join(     os.path.abspath(\"\"), \"data\", \"quantum-scar-dynamics-emulation.json\" )  if not os.path.isfile(emu_filename):     emu_batch = batch.bloqade.python().run(1000)     save(emu_batch, emu_filename)   filename = os.path.join(os.path.abspath(\"\"), \"data\", \"quantum-scar-dynamics-job.json\")  if not os.path.isfile(filename):     hardware_batch = (         batch.parallelize(24)         .braket.aquila()         .run_async(100, ignore_submission_error=True)     )     save(hardware_batch, filename) In\u00a0[3]: Copied! <pre>emu_batch = load(emu_filename)\nhardware_batch = load(filename)\n# hardware_batch.fetch()\n# save(hardware_batch, filename)\n</pre>  emu_batch = load(emu_filename) hardware_batch = load(filename) # hardware_batch.fetch() # save(hardware_batch, filename) In\u00a0[4]: Copied! <pre>def get_z2_probabilities(report):\n    z2_probabilities = []\n\n    for count in report.counts():\n        z2_probability = count.get(\"01010101010\", 0) / sum(list(count.values()))\n        z2_probabilities.append(z2_probability)\n\n    return z2_probabilities\n</pre> def get_z2_probabilities(report):     z2_probabilities = []      for count in report.counts():         z2_probability = count.get(\"01010101010\", 0) / sum(list(count.values()))         z2_probabilities.append(z2_probability)      return z2_probabilities <p>We can now plot the results from the emulator and hardware. We see that the emulator</p> In\u00a0[5]: Copied! <pre>emu_report = emu_batch.report()\nhardware_report = hardware_batch.report()\n\nemu_run_times = emu_report.list_param(\"run_time\")\nemu_z2_prob = get_z2_probabilities(emu_report)\n\nhw_run_times = hardware_report.list_param(\"run_time\")\nhw_z2_prob = get_z2_probabilities(hardware_report)\n\nplt.plot(emu_run_times, emu_z2_prob, label=\"Emulator\", color=\"#878787\")\nplt.plot(hw_run_times, hw_z2_prob, label=\"QPU\", color=\"#6437FF\")\n\nplt.legend()\nplt.xlabel(\"Time ($\\mu s$)\")\nplt.ylabel(\"Z2-state Probability\")\nplt.show()\n</pre>   emu_report = emu_batch.report() hardware_report = hardware_batch.report()  emu_run_times = emu_report.list_param(\"run_time\") emu_z2_prob = get_z2_probabilities(emu_report)  hw_run_times = hardware_report.list_param(\"run_time\") hw_z2_prob = get_z2_probabilities(hardware_report)  plt.plot(emu_run_times, emu_z2_prob, label=\"Emulator\", color=\"#878787\") plt.plot(hw_run_times, hw_z2_prob, label=\"QPU\", color=\"#6437FF\")  plt.legend() plt.xlabel(\"Time ($\\mu s$)\") plt.ylabel(\"Z2-state Probability\") plt.show() <pre>&lt;&gt;:14: SyntaxWarning: invalid escape sequence '\\m'\n&lt;&gt;:14: SyntaxWarning: invalid escape sequence '\\m'\n/tmp/ipykernel_2335/4141403094.py:14: SyntaxWarning: invalid escape sequence '\\m'\n  plt.xlabel(\"Time ($\\mu s$)\")\n</pre>"},{"location":"examples/example-4-quantum-scar-dynamics/#quantum-scar-dynamics","title":"Quantum Scar Dynamics\u00b6","text":""},{"location":"examples/example-4-quantum-scar-dynamics/#introduction","title":"Introduction\u00b6","text":"<p>In this example we show how to use Bloqade to run a quantum scar dynamics experiment. The protocol is as follows: We first prepare the atoms in a Z2 state using an adiabatic sweep. We then apply a Rabi pulse to the atoms, which will cause the atoms to oscillate but because of the Blockade effect, the atoms will not be able to transition to the Rydberg state. However, the atoms will still oscillate between the ground and some other excited many-body states.</p>"},{"location":"examples/example-4-quantum-scar-dynamics/#define-the-program","title":"Define the program\u00b6","text":"<p>This notebook will also show some advanced features of Bloqade, in particular, how to use the <code>slice</code> and <code>record</code> API to build a program that is compatible with the hardware constraints that the rabi drive must be 0 at the end of the protocol.</p> <p>The idea is that first we define the full waveform we would like to apply to the atoms then after defining the full waveform you simply call the <code>slice</code> method to slice the that waveform stopping at a variable time <code>run_time</code>. This works fine for detuning but for the Rabi drive, we need to make sure that the Rabi drive is 0 at the end of the the waveform. To do this, we use the <code>record</code> method to record the value of the Rabi drive at the end of the waveform. We then use the <code>linear</code> method to append a segment to the waveform that fixes the value of the Rabi drive to 0 at the end of the waveform. Now any value of <code>run_time</code> will be a valid waveform that is compatible with the hardware constraints.</p>"},{"location":"examples/example-4-quantum-scar-dynamics/#run-on-emulator-and-hardware","title":"Run on Emulator and Hardware\u00b6","text":"<p>We will run the experiment on the emulator and hardware, saving the results to disk so that we can plot them later. for more details on where these lines of code come from, see the first few tutorials.</p> <p>Hardware Execution Cost</p> <p> <p>For this particular program, 191 tasks are generated with each task having 100 shots, amounting to USD \\$248.30 on AWS Braket.</p> </p>"},{"location":"examples/example-4-quantum-scar-dynamics/#plotting-the-results","title":"Plotting the results\u00b6","text":"<p>The quantity we are interested in is the probability of the atoms being in the Z2 state. We can get this by looking at the counts of the Z2 state in the report Below we define a function that will get the probability of the Z2 state for each time step in the experiment.</p>"},{"location":"examples/example-5-MIS-UDG/","title":"Solving the Maximal Independent Set Problem on defective King Graph","text":"<p> Download Script   Download Job </p> <p>Job Files for Complete Examples</p> <p> To be able to run the complete examples without having to submit your program to hardware and wait, you'll need to download the associated job files. These files contain the results of running the program on the quantum hardware.  <p>You can download the job files by clicking the \"Download Job\" button above. You'll then need to place the job file in the <code>data</code> directory that was created for you when you ran the <code>import</code> part of the script (alternatively you can make the directory yourself, it should live at the same level as wherever you put this script).</p> </p> In\u00a0[1]: Copied! <pre>import os\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom bloqade.analog import load, save\nfrom bloqade.analog.atom_arrangement import Square\n\nif not os.path.isdir(\"data\"):\n    os.mkdir(\"data\")\n\n# setting the seed\nrng = np.random.default_rng(1234)\n\ndurations = [0.3, 1.6, 0.3]\n\nmis_udg_program = (\n    Square(15, lattice_spacing=5.0)\n    .apply_defect_density(0.3, rng=rng)\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(durations, [0.0, 15.0, 15.0, 0.0])\n    .detuning.uniform.piecewise_linear(\n        durations, [-30, -30, \"final_detuning\", \"final_detuning\"]\n    )\n)\n\nmis_udg_job = mis_udg_program.batch_assign(final_detuning=np.linspace(0, 80, 41))\n</pre> import os  import numpy as np import matplotlib.pyplot as plt from bloqade.analog import load, save from bloqade.analog.atom_arrangement import Square  if not os.path.isdir(\"data\"):     os.mkdir(\"data\")  # setting the seed rng = np.random.default_rng(1234)  durations = [0.3, 1.6, 0.3]  mis_udg_program = (     Square(15, lattice_spacing=5.0)     .apply_defect_density(0.3, rng=rng)     .rydberg.rabi.amplitude.uniform.piecewise_linear(durations, [0.0, 15.0, 15.0, 0.0])     .detuning.uniform.piecewise_linear(         durations, [-30, -30, \"final_detuning\", \"final_detuning\"]     ) )  mis_udg_job = mis_udg_program.batch_assign(final_detuning=np.linspace(0, 80, 41)) In\u00a0[2]: Copied! <pre>filename = os.path.join(os.path.abspath(\"\"), \"data\", \"MIS-UDG-job.json\")\n\nif not os.path.isfile(filename):\n    hw_batch = mis_udg_job.braket.aquila().run_async(shots=100)\n    save(hw_batch, filename)\n</pre> filename = os.path.join(os.path.abspath(\"\"), \"data\", \"MIS-UDG-job.json\")  if not os.path.isfile(filename):     hw_batch = mis_udg_job.braket.aquila().run_async(shots=100)     save(hw_batch, filename) In\u00a0[3]: Copied! <pre>batch = load(filename)\n# batch.fetch()\n# save(filename, batch)\n</pre>  batch = load(filename) # batch.fetch() # save(filename, batch) <p>The report object already has a method to calculate the Rydberg densities. We can use this to calculate the average total Rydberg density for each final detuning. then, we can plot the results.</p> In\u00a0[4]: Copied! <pre>report = batch.report()\n\naverage_rydberg_excitation = report.rydberg_densities(filter_perfect_filling=False).sum(\n    axis=1\n)\nfinal_detunings = report.list_param(\"final_detuning\")\n\nplt.plot(final_detunings, average_rydberg_excitation, color=\"#6437FF\")\nplt.xlabel(\"final detuning (rad/\u00b5s)\")\nplt.ylabel(\"total rydberg excitations\")\nplt.show()\n</pre>  report = batch.report()  average_rydberg_excitation = report.rydberg_densities(filter_perfect_filling=False).sum(     axis=1 ) final_detunings = report.list_param(\"final_detuning\")  plt.plot(final_detunings, average_rydberg_excitation, color=\"#6437FF\") plt.xlabel(\"final detuning (rad/\u00b5s)\") plt.ylabel(\"total rydberg excitations\") plt.show()"},{"location":"examples/example-5-MIS-UDG/#solving-the-maximal-independent-set-problem-on-defective-king-graph","title":"Solving the Maximal Independent Set Problem on defective King Graph\u00b6","text":""},{"location":"examples/example-5-MIS-UDG/#introduction","title":"Introduction\u00b6","text":"<p>In this tutorial, we show how to use some of Bloqade's built-in tools to generate a defects in a graph and then use Bloqade to solve the Maximal Independent Set (MIS) problem on a Unit Disk Graph (UDG), which is easily expressible on Neutral Atom Hardware via the Rydberg blockade mechanism. We will not cover hybrid quantum- classical algorithms in this tutorial, but instead, we will use a simple parameter scan to find the optimal detuning value for an adiabatic ramp. We will cover hybrid quantum-classical algorithms in a future tutorial.</p>"},{"location":"examples/example-5-MIS-UDG/#define-the-program","title":"Define the Program.\u00b6","text":"<p>To define random defects on any Bloqade geometry, simply call the <code>add_defect_density</code> or <code>add_defect_count</code> methods on the geometry object. The <code>add_defect_density</code> method takes a float between 0 and 1 and uses that as the probability of a site being a defect. The <code>add_defect_count</code> method takes the number of defects to add to the geometry placed in random locations. Both ways take an  optional <code>rng</code> argument, a numpy random number generator. If no <code>rng</code> argument is provided, then the default numpy random number generator is used. Using the random number generator allows you to set the seed for reproducibility. After that, defining the pulse sequence is the same as in the previous tutorials.</p>"},{"location":"examples/example-5-MIS-UDG/#run-on-hardware","title":"Run On Hardware\u00b6","text":"<p>We can't run on our emulators because the program size is too large. Instead we will run on hardware.</p> <p>Hardware Execution Cost</p> <p> <p>For this particular program, 41 tasks are generated with each task having 100 shots, amounting to USD \\$53.30 on AWS Braket.</p> </p>"},{"location":"examples/example-5-MIS-UDG/#plot-results","title":"Plot Results\u00b6","text":"<p>Here, the total number of Rydberg excitations is plotted as a function of the final detuning. The total number of Rydberg excitations is a proxy for the largest independent set size because the number of violations to the Rydberg blockade is and will not scale with the size of the independent set. We start by loading the results</p>"},{"location":"examples/example-6-lattice-gauge-theory/","title":"Lattice Gauge Theory Simulation","text":"<p> Download Script   Download Job </p> <p>Job Files for Complete Examples</p> <p> To be able to run the complete examples without having to submit your program to hardware and wait, you'll need to download the associated job files. These files contain the results of running the program on the quantum hardware.  <p>You can download the job files by clicking the \"Download Job\" button above. You'll then need to place the job file in the <code>data</code> directory that was created for you when you ran the <code>import</code> part of the script (alternatively you can make the directory yourself, it should live at the same level as wherever you put this script).</p> </p> In\u00a0[1]: Copied! <pre>import os\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom bloqade.analog import cast, load, save, piecewise_linear\nfrom bloqade.analog.ir.location import Chain\n\nif not os.path.isdir(\"data\"):\n    os.mkdir(\"data\")\n</pre> import os  import numpy as np import matplotlib.pyplot as plt from bloqade.analog import cast, load, save, piecewise_linear from bloqade.analog.ir.location import Chain  if not os.path.isdir(\"data\"):     os.mkdir(\"data\") <p>We introduce two new features of Bloqade here in order to accomplish this LGT simulation.</p> <p>Firstly, instead of building the waveforms off the program itself using methods like <code>.piecewise_linear</code> and <code>.piecewise_constant</code> as seen in previous tutorials, we build the waveforms outside the program and then use the <code>.apply</code> method to put them into the program. This is similar to the Multi-qubit Blockaded Rabi Oscillations tutorial except instead of building an entire program without a geometry and then applying it on top of one, we introduce waveforms to an existing program structure.</p> <p>For complex programs such as this one this makes prototyping significantly easier (you can view individual waveforms by calling <code>.show()</code> on them so long as there are no variables in the waveform) and keeps things modular.</p> <p>Secondly, we need to be able to \"selectively address\" certain atoms. This is accomplished via Local Detuning where we are able to control how much of the global detuning is applied to each atom through a multiplicative scaling factor.</p> <p>Bloqade has two methods of doing this (refer to the \"Advanced Usage\" page) but here we opt for the <code>.scale</code> method. We create a list of values from 0 to 1 with length equal to the number of atoms in the system. A value of 1 means the atom should experience the full detuning waveform while 0 means the atom should not experience it at all. The n-th value in the list corresponds to the n-th atom in the system.</p> In\u00a0[2]: Copied! <pre>N_atom = 13\n# Setup the detuning scaling per atom.\n# Note that the list of scaling values has a length equal to\n# the number of atoms\ndetuning_ratio = [0] * N_atom\ndetuning_ratio[1 : (N_atom - 1) : 2] = [1, 1, 1, 1, 1, 1]\ndetuning_ratio[(N_atom - 1) // 2] = 1\n# Notice that the detuning ratio will allow us to prepare a Z2\n# ordered phase. However, the sequence of contiguous 1s in the\n# middle introduce a defect.\ndetuning_ratio\n</pre> N_atom = 13 # Setup the detuning scaling per atom. # Note that the list of scaling values has a length equal to # the number of atoms detuning_ratio = [0] * N_atom detuning_ratio[1 : (N_atom - 1) : 2] = [1, 1, 1, 1, 1, 1] detuning_ratio[(N_atom - 1) // 2] = 1 # Notice that the detuning ratio will allow us to prepare a Z2 # ordered phase. However, the sequence of contiguous 1s in the # middle introduce a defect. detuning_ratio Out[2]: <pre>[0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0]</pre> In\u00a0[3]: Copied! <pre>run_time = cast(\"run_time\")\n\n# Define our waveforms first, then plug them into the\n# program structure below\nrabi_amplitude_wf = piecewise_linear(\n    durations=[0.1, 2.0, 0.05, run_time, 0.05],\n    values=[0, 5 * np.pi, 5 * np.pi, 4 * np.pi, 4 * np.pi, 0],\n)\nuniform_detuning_wf = piecewise_linear(\n    durations=[2.1, 0.05, run_time + 0.05], values=[-6 * np.pi, 8 * np.pi, 0, 0]\n)\nlocal_detuning_wf = piecewise_linear(\n    [0.1, 2.0, 0.05, run_time + 0.05], values=[0, -8 * 2 * np.pi, -8 * 2 * np.pi, 0, 0]\n)\n\n# Note that `scale` is called right after defining the\n# global detuning\nprogram = (\n    Chain(N_atom, lattice_spacing=5.5, vertical_chain=True)\n    .rydberg.rabi.amplitude.uniform.apply(rabi_amplitude_wf)\n    .detuning.uniform.apply(uniform_detuning_wf)\n    .scale(detuning_ratio)\n    .apply(local_detuning_wf)\n)\n\nrun_times = np.arange(0.0, 1.05, 0.05)\nbatch = program.batch_assign(run_time=run_times)\n</pre> run_time = cast(\"run_time\")  # Define our waveforms first, then plug them into the # program structure below rabi_amplitude_wf = piecewise_linear(     durations=[0.1, 2.0, 0.05, run_time, 0.05],     values=[0, 5 * np.pi, 5 * np.pi, 4 * np.pi, 4 * np.pi, 0], ) uniform_detuning_wf = piecewise_linear(     durations=[2.1, 0.05, run_time + 0.05], values=[-6 * np.pi, 8 * np.pi, 0, 0] ) local_detuning_wf = piecewise_linear(     [0.1, 2.0, 0.05, run_time + 0.05], values=[0, -8 * 2 * np.pi, -8 * 2 * np.pi, 0, 0] )  # Note that `scale` is called right after defining the # global detuning program = (     Chain(N_atom, lattice_spacing=5.5, vertical_chain=True)     .rydberg.rabi.amplitude.uniform.apply(rabi_amplitude_wf)     .detuning.uniform.apply(uniform_detuning_wf)     .scale(detuning_ratio)     .apply(local_detuning_wf) )  run_times = np.arange(0.0, 1.05, 0.05) batch = program.batch_assign(run_time=run_times) In\u00a0[4]: Copied! <pre>emu_filename = os.path.join(os.path.abspath(\"\"), \"data\", \"lgt-emulation.json\")\n\nif not os.path.isfile(emu_filename):\n    emu_batch = batch.bloqade.python().run(1000, rtol=1e-10)\n    save(emu_batch, emu_filename)\n</pre> emu_filename = os.path.join(os.path.abspath(\"\"), \"data\", \"lgt-emulation.json\")  if not os.path.isfile(emu_filename):     emu_batch = batch.bloqade.python().run(1000, rtol=1e-10)     save(emu_batch, emu_filename) In\u00a0[5]: Copied! <pre>filename = os.path.join(os.path.abspath(\"\"), \"data\", \"lgt-job.json\")\n\nif not os.path.isfile(filename):\n    hardware_batch = batch.parallelize(15).braket.aquila().run_async(shots=200)\n    save(hardware_batch, filename)\n</pre> filename = os.path.join(os.path.abspath(\"\"), \"data\", \"lgt-job.json\")  if not os.path.isfile(filename):     hardware_batch = batch.parallelize(15).braket.aquila().run_async(shots=200)     save(hardware_batch, filename) In\u00a0[6]: Copied! <pre>emu_batch = load(emu_filename)\nhardware_batch = load(filename)\n</pre> emu_batch = load(emu_filename) hardware_batch = load(filename) <p>The following code plots the Rydberg onsite density from emulation as a function of evolution time after preparing the initial state with a defect in the middle. We observe that this defect propagates ballistically to the boundary and bounces back and forth.</p> In\u00a0[7]: Copied! <pre>emu_report = emu_batch.report()\nemu_rydberg_densities = emu_report.rydberg_densities()\n\nplt.imshow(np.array(emu_rydberg_densities).T, vmin=0, vmax=1)\nplt.xticks(\n    ticks=np.arange(0, 20, 2), labels=np.round(np.arange(0.0, 1.0, 0.1), 1), minor=False\n)\nplt.xlabel(\"t[us]\", fontsize=14)\nplt.ylabel(\"atom\", fontsize=14)\nplt.title(\"simulation\", fontsize=14)\nplt.colorbar(shrink=0.68)\nplt.show()\n</pre> emu_report = emu_batch.report() emu_rydberg_densities = emu_report.rydberg_densities()  plt.imshow(np.array(emu_rydberg_densities).T, vmin=0, vmax=1) plt.xticks(     ticks=np.arange(0, 20, 2), labels=np.round(np.arange(0.0, 1.0, 0.1), 1), minor=False ) plt.xlabel(\"t[us]\", fontsize=14) plt.ylabel(\"atom\", fontsize=14) plt.title(\"simulation\", fontsize=14) plt.colorbar(shrink=0.68) plt.show() <p>Additionally, we can plot the correlation between nearest-neighbor sites to illustrate the propagation of the defect across the chain.</p> In\u00a0[8]: Copied! <pre>def rydberg_correlation(task_bits: np.ndarray, i: int, j: int) -&gt; np.ndarray:\n    return np.mean(task_bits[:, i] * task_bits[:, j])\n\n\nemu_bitstrings = emu_report.bitstrings()\nbits = np.array(emu_bitstrings)\nnum_tasks = len(bits)\ncorrs = np.zeros((num_tasks, N_atom - 1), dtype=np.float64)\nfor task_index, task_bits in enumerate(bits):\n    for i in range(N_atom - 1):\n        corrs[task_index, i] = rydberg_correlation(task_bits, i, i + 1)\n\nplt.imshow(corrs.T, vmin=0, vmax=1)\nplt.xticks(\n    ticks=np.arange(0, 20, 2), labels=np.round(np.arange(0.0, 1.0, 0.1), 1), minor=False\n)\nplt.xlabel(\"t[us]\")\nplt.ylabel(\"atom\")\nplt.title(\"simulation\")\nplt.colorbar(shrink=0.68)\nplt.show()\n</pre> def rydberg_correlation(task_bits: np.ndarray, i: int, j: int) -&gt; np.ndarray:     return np.mean(task_bits[:, i] * task_bits[:, j])   emu_bitstrings = emu_report.bitstrings() bits = np.array(emu_bitstrings) num_tasks = len(bits) corrs = np.zeros((num_tasks, N_atom - 1), dtype=np.float64) for task_index, task_bits in enumerate(bits):     for i in range(N_atom - 1):         corrs[task_index, i] = rydberg_correlation(task_bits, i, i + 1)  plt.imshow(corrs.T, vmin=0, vmax=1) plt.xticks(     ticks=np.arange(0, 20, 2), labels=np.round(np.arange(0.0, 1.0, 0.1), 1), minor=False ) plt.xlabel(\"t[us]\") plt.ylabel(\"atom\") plt.title(\"simulation\") plt.colorbar(shrink=0.68) plt.show() <p>As observed below, the state with a local defect in the middle can be prepared with high fidelity on Aquila. Following the preparation stage, akin to the emulation, the defect rapidly propagates across the system.</p> In\u00a0[9]: Copied! <pre>aquila_rydberg_densities = hardware_batch.report().rydberg_densities()\n\nplt.imshow(np.array(aquila_rydberg_densities).T, vmin=0, vmax=0.8)\nplt.xticks(\n    ticks=np.arange(0, 20, 2), labels=np.round(np.arange(0.0, 1.0, 0.1), 1), minor=False\n)\nplt.xlabel(\"t[us]\", fontsize=14)\nplt.ylabel(\"atom\", fontsize=14)\nplt.title(\"Aquila\", fontsize=14)\nplt.colorbar(shrink=0.68)\nplt.show()\n</pre> aquila_rydberg_densities = hardware_batch.report().rydberg_densities()  plt.imshow(np.array(aquila_rydberg_densities).T, vmin=0, vmax=0.8) plt.xticks(     ticks=np.arange(0, 20, 2), labels=np.round(np.arange(0.0, 1.0, 0.1), 1), minor=False ) plt.xlabel(\"t[us]\", fontsize=14) plt.ylabel(\"atom\", fontsize=14) plt.title(\"Aquila\", fontsize=14) plt.colorbar(shrink=0.68) plt.show()"},{"location":"examples/example-6-lattice-gauge-theory/#lattice-gauge-theory-simulation","title":"Lattice Gauge Theory Simulation\u00b6","text":""},{"location":"examples/example-6-lattice-gauge-theory/#introduction","title":"Introduction\u00b6","text":"<p>In this notebook, we utilize Aquila to simulate the dynamics of a Lattice Gauge Theory (LGT) with a 1D Rydberg atom chain. In the realm of gauge theories, it has been discovered that the Z2 ground state and the quantum scar of the Rydberg chain correspond to the 'string' state and the string-inversion mechanism of the studied LGT, respectively. More intriguingly, by selectively addressing certain atoms, we can induce defects in the chain and simulate the propagation of particle-antiparticle pairs. This notebook is inspired by the paper by F. M. Surace et al. (DOI: 10.1103/PhysRevX.10.021041).</p>"},{"location":"examples/example-6-lattice-gauge-theory/#define-the-program","title":"Define the Program\u00b6","text":""},{"location":"examples/example-6-lattice-gauge-theory/#run-on-emulator-and-hardware","title":"Run on Emulator and Hardware\u00b6","text":"<p>We now run the program on both the emulator and quantum hardware.</p> <p>Hardware Execution Cost</p> <p> <p>For this particular program, 21 tasks are generated with each task having 200 shots, amounting to USD \\$48.30 on AWS Braket.</p> </p>"},{"location":"examples/example-6-lattice-gauge-theory/#plot-the-results","title":"Plot the Results\u00b6","text":""},{"location":"reference/example_package/","title":"Index","text":""},{"location":"scripts/gen_ref_nav/","title":"Gen ref nav","text":"In\u00a0[1]: Copied! <pre>\"\"\"Generate the code reference pages and navigation.\"\"\"\n</pre> \"\"\"Generate the code reference pages and navigation.\"\"\" Out[1]: <pre>'Generate the code reference pages and navigation.'</pre> In\u00a0[2]: Copied! <pre>from pathlib import Path\n</pre> from pathlib import Path In\u00a0[3]: Copied! <pre>import mkdocs_gen_files\n</pre> import mkdocs_gen_files In\u00a0[4]: Copied! <pre>SRC_PATH = \"src\"\n</pre> SRC_PATH = \"src\" In\u00a0[5]: Copied! <pre>skip_keywords = [\n    \"julia\",  ## [KHW] skip for now since we didn't have julia codegen rdy\n    \"builder/base\",  ## hiding from user\n    \"builder/terminate\",  ## hiding from user\n    \"ir/tree_print\",  ## hiding from user\n    \"ir/visitor\",  ## hiding from user\n    \"codegen/\",  ## hiding from user\n    \"builder/factory\",  ## hiding from user\n    \"builder_old\",  ## deprecated from user\n    \"task_old\",  ## deprecated from user\n    \"visualization\",  ## hiding from user\n    \"submission/capabilities\",  ## hiding from user\n    \"submission/quera_api_client\",\n]\n</pre> skip_keywords = [     \"julia\",  ## [KHW] skip for now since we didn't have julia codegen rdy     \"builder/base\",  ## hiding from user     \"builder/terminate\",  ## hiding from user     \"ir/tree_print\",  ## hiding from user     \"ir/visitor\",  ## hiding from user     \"codegen/\",  ## hiding from user     \"builder/factory\",  ## hiding from user     \"builder_old\",  ## deprecated from user     \"task_old\",  ## deprecated from user     \"visualization\",  ## hiding from user     \"submission/capabilities\",  ## hiding from user     \"submission/quera_api_client\", ] In\u00a0[6]: Copied! <pre>nav = mkdocs_gen_files.Nav()\nfor path in sorted(Path(SRC_PATH).rglob(\"*.py\")):\n    module_path = path.relative_to(SRC_PATH).with_suffix(\"\")\n    doc_path = path.relative_to(SRC_PATH).with_suffix(\".md\")\n    full_doc_path = Path(\"reference\", doc_path)\n\n    iskip = False\n\n    for kwrd in skip_keywords:\n        if kwrd in str(doc_path):\n            iskip = True\n            break\n    if iskip:\n        print(\"[Ignore]\", str(doc_path))\n        continue\n\n    print(\"[&gt;]\", str(doc_path))\n\n    parts = tuple(module_path.parts)\n\n    if parts[-1] == \"__init__\":\n        parts = parts[:-1]\n        doc_path = doc_path.with_name(\"index.md\")\n        full_doc_path = full_doc_path.with_name(\"index.md\")\n    elif parts[-1].startswith(\"_\"):\n        continue\n\n    nav[parts] = doc_path.as_posix()\n    with mkdocs_gen_files.open(full_doc_path, \"w\") as fd:\n        ident = \".\".join(parts)\n        fd.write(f\"::: {ident}\")\n\n    mkdocs_gen_files.set_edit_path(full_doc_path, \"..\" / path)\n</pre> nav = mkdocs_gen_files.Nav() for path in sorted(Path(SRC_PATH).rglob(\"*.py\")):     module_path = path.relative_to(SRC_PATH).with_suffix(\"\")     doc_path = path.relative_to(SRC_PATH).with_suffix(\".md\")     full_doc_path = Path(\"reference\", doc_path)      iskip = False      for kwrd in skip_keywords:         if kwrd in str(doc_path):             iskip = True             break     if iskip:         print(\"[Ignore]\", str(doc_path))         continue      print(\"[&gt;]\", str(doc_path))      parts = tuple(module_path.parts)      if parts[-1] == \"__init__\":         parts = parts[:-1]         doc_path = doc_path.with_name(\"index.md\")         full_doc_path = full_doc_path.with_name(\"index.md\")     elif parts[-1].startswith(\"_\"):         continue      nav[parts] = doc_path.as_posix()     with mkdocs_gen_files.open(full_doc_path, \"w\") as fd:         ident = \".\".join(parts)         fd.write(f\"::: {ident}\")      mkdocs_gen_files.set_edit_path(full_doc_path, \"..\" / path) <pre>[&gt;] example_package/__init__.md\n</pre> In\u00a0[7]: Copied! <pre>with mkdocs_gen_files.open(\"reference/SUMMARY.txt\", \"w\") as nav_file:\n    nav_file.writelines(nav.build_literate_nav())\n</pre> with mkdocs_gen_files.open(\"reference/SUMMARY.txt\", \"w\") as nav_file:     nav_file.writelines(nav.build_literate_nav())"}]}